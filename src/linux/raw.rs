/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_database {
    _unused: [u8; 0],
}
/// A Hyperscan pattern database.
///
/// Generated by one of the Hyperscan compiler functions:
/// - @ref hs_compile()
/// - @ref hs_compile_multi()
/// - @ref hs_compile_ext_multi()
pub type hs_database_t = hs_database;
/// A type for errors returned by Hyperscan functions.
pub type hs_error_t = ::std::os::raw::c_int;
extern "C" {
    /// Free a compiled pattern database.
    ///
    /// The free callback set by @ref hs_set_database_allocator() (or @ref
    /// hs_set_allocator()) will be used by this function.
    ///
    /// @param db
    /// A compiled pattern database. NULL may also be safely provided, in which
    /// case the function does nothing.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_free_database(db: *mut hs_database_t) -> hs_error_t;
}
extern "C" {
    /// Serialize a pattern database to a stream of bytes.
    ///
    /// The allocator callback set by @ref hs_set_misc_allocator() (or @ref
    /// hs_set_allocator()) will be used by this function.
    ///
    /// @param db
    /// A compiled pattern database.
    ///
    /// @param bytes
    /// On success, a pointer to an array of bytes will be returned here.
    /// These bytes can be subsequently relocated or written to disk. The
    /// caller is responsible for freeing this block.
    ///
    /// @param length
    /// On success, the number of bytes in the generated byte array will be
    /// returned here.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, @ref HS_NOMEM if the byte array cannot be
    /// allocated, other values may be returned if errors are detected.
    pub fn hs_serialize_database(
        db: *const hs_database_t,
        bytes: *mut *mut ::std::os::raw::c_char,
        length: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    /// Reconstruct a pattern database from a stream of bytes previously generated
    /// by @ref hs_serialize_database().
    ///
    /// This function will allocate sufficient space for the database using the
    /// allocator set with @ref hs_set_database_allocator() (or @ref
    /// hs_set_allocator()); to use a pre-allocated region of memory, use the @ref
    /// hs_deserialize_database_at() function.
    ///
    /// @param bytes
    /// A byte array generated by @ref hs_serialize_database() representing a
    /// compiled pattern database.
    ///
    /// @param length
    /// The length of the byte array generated by @ref hs_serialize_database().
    /// This should be the same value as that returned by @ref
    /// hs_serialize_database().
    ///
    /// @param db
    /// On success, a pointer to a newly allocated @ref hs_database_t will be
    /// returned here. This database can then be used for scanning, and
    /// eventually freed by the caller using @ref hs_free_database().
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_deserialize_database(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        db: *mut *mut hs_database_t,
    ) -> hs_error_t;
}
extern "C" {
    /// Reconstruct a pattern database from a stream of bytes previously generated
    /// by @ref hs_serialize_database() at a given memory location.
    ///
    /// This function (unlike @ref hs_deserialize_database()) will write the
    /// reconstructed database to the memory location given in the @p db parameter.
    /// The amount of space required at this location can be determined with the
    /// @ref hs_serialized_database_size() function.
    ///
    /// @param bytes
    /// A byte array generated by @ref hs_serialize_database() representing a
    /// compiled pattern database.
    ///
    /// @param length
    /// The length of the byte array generated by @ref hs_serialize_database().
    /// This should be the same value as that returned by @ref
    /// hs_serialize_database().
    ///
    /// @param db
    /// Pointer to an 8-byte aligned block of memory of sufficient size to hold
    /// the deserialized database. On success, the reconstructed database will
    /// be written to this location. This database can then be used for pattern
    /// matching. The user is responsible for freeing this memory; the @ref
    /// hs_free_database() call should not be used.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_deserialize_database_at(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        db: *mut hs_database_t,
    ) -> hs_error_t;
}
extern "C" {
    /// Provides the size of the stream state allocated by a single stream opened
    /// against the given database.
    ///
    /// @param database
    /// Pointer to a compiled (streaming mode) pattern database.
    ///
    /// @param stream_size
    /// On success, the size in bytes of an individual stream opened against the
    /// given database is placed in this parameter.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_stream_size(database: *const hs_database_t, stream_size: *mut usize) -> hs_error_t;
}
extern "C" {
    /// Provides the size of the given database in bytes.
    ///
    /// @param database
    /// Pointer to compiled pattern database.
    ///
    /// @param database_size
    /// On success, the size of the compiled database in bytes is placed in this
    /// parameter.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_database_size(database: *const hs_database_t, database_size: *mut usize) -> hs_error_t;
}
extern "C" {
    /// Utility function for reporting the size that would be required by a
    /// database if it were deserialized.
    ///
    /// This can be used to allocate a shared memory region or other "special"
    /// allocation prior to deserializing with the @ref hs_deserialize_database_at()
    /// function.
    ///
    /// @param bytes
    /// Pointer to a byte array generated by @ref hs_serialize_database()
    /// representing a compiled pattern database.
    ///
    /// @param length
    /// The length of the byte array generated by @ref hs_serialize_database().
    /// This should be the same value as that returned by @ref
    /// hs_serialize_database().
    ///
    /// @param deserialized_size
    /// On success, the size of the compiled database that would be generated
    /// by @ref hs_deserialize_database_at() is returned here.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_serialized_database_size(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        deserialized_size: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    /// Utility function providing information about a database.
    ///
    /// @param database
    /// Pointer to a compiled database.
    ///
    /// @param info
    /// On success, a string containing the version and platform information for
    /// the supplied database is placed in the parameter. The string is
    /// allocated using the allocator supplied in @ref hs_set_misc_allocator()
    /// (or malloc() if no allocator was set) and should be freed by the caller.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_database_info(database: *const hs_database_t, info: *mut *mut ::std::os::raw::c_char) -> hs_error_t;
}
extern "C" {
    /// Utility function providing information about a serialized database.
    ///
    /// @param bytes
    /// Pointer to a serialized database.
    ///
    /// @param length
    /// Length in bytes of the serialized database.
    ///
    /// @param info
    /// On success, a string containing the version and platform information
    /// for the supplied serialized database is placed in the parameter. The
    /// string is allocated using the allocator supplied in @ref
    /// hs_set_misc_allocator() (or malloc() if no allocator was set) and
    /// should be freed by the caller.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_serialized_database_info(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        info: *mut *mut ::std::os::raw::c_char,
    ) -> hs_error_t;
}
/// The type of the callback function that will be used by Hyperscan to allocate
/// more memory at runtime as required, for example in @ref hs_open_stream() to
/// allocate stream state.
///
/// If Hyperscan is to be used in a multi-threaded, or similarly concurrent
/// environment, the allocation function will need to be re-entrant, or
/// similarly safe for concurrent use.
///
/// @param size
/// The number of bytes to allocate.
/// @return
/// A pointer to the region of memory allocated, or NULL on error.
pub type hs_alloc_t = ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
/// The type of the callback function that will be used by Hyperscan to free
/// memory regions previously allocated using the @ref hs_alloc_t function.
///
/// @param ptr
/// The region of memory to be freed.
pub type hs_free_t = ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    /// Set the allocate and free functions used by Hyperscan for allocating
    /// memory at runtime for stream state, scratch space, database bytecode,
    /// and various other data structure returned by the Hyperscan API.
    ///
    /// The function is equivalent to calling @ref hs_set_stream_allocator(),
    /// @ref hs_set_scratch_allocator(), @ref hs_set_database_allocator() and
    /// @ref hs_set_misc_allocator() with the provided parameters.
    ///
    /// This call will override any previous allocators that have been set.
    ///
    /// Note: there is no way to change the allocator used for temporary objects
    /// created during the various compile calls (@ref hs_compile(), @ref
    /// hs_compile_multi(), @ref hs_compile_ext_multi()).
    ///
    /// @param alloc_func
    /// A callback function pointer that allocates memory. This function must
    /// return memory suitably aligned for the largest representable data type
    /// on this platform.
    ///
    /// @param free_func
    /// A callback function pointer that frees allocated memory.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_set_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    /// Set the allocate and free functions used by Hyperscan for allocating memory
    /// for database bytecode produced by the compile calls (@ref hs_compile(), @ref
    /// hs_compile_multi(), @ref hs_compile_ext_multi()) and by database
    /// deserialization (@ref hs_deserialize_database()).
    ///
    /// If no database allocation functions are set, or if NULL is used in place of
    /// both parameters, then memory allocation will default to standard methods
    /// (such as the system malloc() and free() calls).
    ///
    /// This call will override any previous database allocators that have been set.
    ///
    /// Note: the database allocator may also be set by calling @ref
    /// hs_set_allocator().
    ///
    /// Note: there is no way to change how temporary objects created during the
    /// various compile calls (@ref hs_compile(), @ref hs_compile_multi(), @ref
    /// hs_compile_ext_multi()) are allocated.
    ///
    /// @param alloc_func
    /// A callback function pointer that allocates memory. This function must
    /// return memory suitably aligned for the largest representable data type
    /// on this platform.
    ///
    /// @param free_func
    /// A callback function pointer that frees allocated memory.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_set_database_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    /// Set the allocate and free functions used by Hyperscan for allocating memory
    /// for items returned by the Hyperscan API such as @ref hs_compile_error_t, @ref
    /// hs_expr_info_t and serialized databases.
    ///
    /// If no misc allocation functions are set, or if NULL is used in place of both
    /// parameters, then memory allocation will default to standard methods (such as
    /// the system malloc() and free() calls).
    ///
    /// This call will override any previous misc allocators that have been set.
    ///
    /// Note: the misc allocator may also be set by calling @ref hs_set_allocator().
    ///
    /// @param alloc_func
    /// A callback function pointer that allocates memory. This function must
    /// return memory suitably aligned for the largest representable data type
    /// on this platform.
    ///
    /// @param free_func
    /// A callback function pointer that frees allocated memory.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_set_misc_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    /// Set the allocate and free functions used by Hyperscan for allocating memory
    /// for scratch space by @ref hs_alloc_scratch() and @ref hs_clone_scratch().
    ///
    /// If no scratch allocation functions are set, or if NULL is used in place of
    /// both parameters, then memory allocation will default to standard methods
    /// (such as the system malloc() and free() calls).
    ///
    /// This call will override any previous scratch allocators that have been set.
    ///
    /// Note: the scratch allocator may also be set by calling @ref
    /// hs_set_allocator().
    ///
    /// @param alloc_func
    /// A callback function pointer that allocates memory. This function must
    /// return memory suitably aligned for the largest representable data type
    /// on this platform.
    ///
    /// @param free_func
    /// A callback function pointer that frees allocated memory.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_set_scratch_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    /// Set the allocate and free functions used by Hyperscan for allocating memory
    /// for stream state by @ref hs_open_stream().
    ///
    /// If no stream allocation functions are set, or if NULL is used in place of
    /// both parameters, then memory allocation will default to standard methods
    /// (such as the system malloc() and free() calls).
    ///
    /// This call will override any previous stream allocators that have been set.
    ///
    /// Note: the stream allocator may also be set by calling @ref
    /// hs_set_allocator().
    ///
    /// @param alloc_func
    /// A callback function pointer that allocates memory. This function must
    /// return memory suitably aligned for the largest representable data type
    /// on this platform.
    ///
    /// @param free_func
    /// A callback function pointer that frees allocated memory.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_set_stream_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    /// Utility function for identifying this release version.
    ///
    /// @return
    /// A string containing the version number of this release build and the
    /// date of the build. It is allocated statically, so it does not need to
    /// be freed by the caller.
    pub fn hs_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Utility function to test the current system architecture.
    ///
    /// Hyperscan requires the Supplemental Streaming SIMD Extensions 3 instruction
    /// set. This function can be called on any x86 platform to determine if the
    /// system provides the required instruction set.
    ///
    /// This function does not test for more advanced features if Hyperscan has
    /// been built for a more specific architecture, for example the AVX2
    /// instruction set.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, @ref HS_ARCH_ERROR if system does not
    /// support Hyperscan.
    pub fn hs_valid_platform() -> hs_error_t;
}
/// A type containing error details that is returned by the compile calls (@ref
/// hs_compile(), @ref hs_compile_multi() and @ref hs_compile_ext_multi()) on
/// failure. The caller may inspect the values returned in this type to
/// determine the cause of failure.
///
/// Common errors generated during the compile process include:
///
/// - *Invalid parameter*
///
/// An invalid argument was specified in the compile call.
///
/// - *Unrecognised flag*
///
/// An unrecognised value was passed in the flags argument.
///
/// - *Pattern matches empty buffer*
///
/// By default, Hyperscan only supports patterns that will *always*
/// consume at least one byte of input. Patterns that do not have this
/// property (such as `/(abc)?/`) will produce this error unless
/// the @ref HS_FLAG_ALLOWEMPTY flag is supplied. Note that such
/// patterns will produce a match for *every* byte when scanned.
///
/// - *Embedded anchors not supported*
///
/// Hyperscan only supports the use of anchor meta-characters (such as
/// `^` and `$`) in patterns where they could *only* match
/// at the start or end of a buffer. A pattern containing an embedded
/// anchor, such as `/abc^def/`, can never match, as there is no
/// way for `abc` to precede the start of the data stream.
///
/// - *Bounded repeat is too large*
///
/// The pattern contains a repeated construct with very large finite
/// bounds.
///
/// - *Unsupported component type*
///
/// An unsupported PCRE construct was used in the pattern.
///
/// - *Unable to generate bytecode*
///
/// This error indicates that Hyperscan was unable to compile a pattern
/// that is syntactically valid. The most common cause is a pattern that is
/// very long and complex or contains a large repeated subpattern.
///
/// - *Unable to allocate memory*
///
/// The library was unable to allocate temporary storage used during
/// compilation time.
///
/// - *Allocator returned misaligned memory*
///
/// The memory allocator (either malloc() or the allocator set with @ref
/// hs_set_allocator()) did not correctly return memory suitably aligned
/// for the largest representable data type on this platform.
///
/// - *Internal error*
///
/// An unexpected error occurred: if this error is reported, please contact
/// the Hyperscan team with a description of the situation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_compile_error {
    /// A human-readable error message describing the error.
    pub message: *mut ::std::os::raw::c_char,
    /// The zero-based number of the expression that caused the error (if this
    /// can be determined). If the error is not specific to an expression, then
    /// this value will be less than zero.
    pub expression: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_hs_compile_error() {
    assert_eq!(
        ::std::mem::size_of::<hs_compile_error>(),
        16usize,
        concat!("Size of: ", stringify!(hs_compile_error))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_compile_error>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_compile_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_compile_error>())).message as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_compile_error),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_compile_error>())).expression as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_compile_error),
            "::",
            stringify!(expression)
        )
    );
}
pub type hs_compile_error_t = hs_compile_error;
/// A type containing information on the target platform which may optionally be
/// provided to the compile calls (@ref hs_compile(), @ref hs_compile_multi(),
/// @ref hs_compile_ext_multi()).
///
/// A hs_platform_info structure may be populated for the current platform by
/// using the @ref hs_populate_platform() call.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_platform_info {
    /// Information about the target platform which may be used to guide the
    /// optimisation process of the compile.
    ///
    /// Use of this field does not limit the processors that the resulting
    /// database can run on, but may impact the performance of the resulting
    /// database.
    pub tune: ::std::os::raw::c_uint,
    /// Relevant CPU features available on the target platform
    ///
    /// This value may be produced by combining HS_CPU_FEATURE_* flags (such as
    /// @ref HS_CPU_FEATURES_AVX2). Multiple CPU features may be or'ed together
    /// to produce the value.
    pub cpu_features: ::std::os::raw::c_ulonglong,
    /// Reserved for future use.
    pub reserved1: ::std::os::raw::c_ulonglong,
    /// Reserved for future use.
    pub reserved2: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hs_platform_info() {
    assert_eq!(
        ::std::mem::size_of::<hs_platform_info>(),
        32usize,
        concat!("Size of: ", stringify!(hs_platform_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_platform_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_platform_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_platform_info>())).tune as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(tune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_platform_info>())).cpu_features as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(cpu_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_platform_info>())).reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_platform_info>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type hs_platform_info_t = hs_platform_info;
/// A type containing information related to an expression that is returned by
/// @ref hs_expression_info() or @ref hs_expression_ext_info.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_expr_info {
    /// The minimum length in bytes of a match for the pattern.
    ///
    /// Note: in some cases when using advanced features to suppress matches
    /// (such as extended parameters or the @ref HS_FLAG_SINGLEMATCH flag) this
    /// may represent a conservative lower bound for the true minimum length of
    /// a match.
    pub min_width: ::std::os::raw::c_uint,
    /// The maximum length in bytes of a match for the pattern. If the pattern
    /// has an unbounded maximum length, this will be set to the maximum value
    /// of an unsigned int (UINT_MAX).
    ///
    /// Note: in some cases when using advanced features to suppress matches
    /// (such as extended parameters or the @ref HS_FLAG_SINGLEMATCH flag) this
    /// may represent a conservative upper bound for the true maximum length of
    /// a match.
    pub max_width: ::std::os::raw::c_uint,
    /// Whether this expression can produce matches that are not returned in
    /// order, such as those produced by assertions. Zero if false, non-zero if
    /// true.
    pub unordered_matches: ::std::os::raw::c_char,
    /// Whether this expression can produce matches at end of data (EOD). In
    /// streaming mode, EOD matches are raised during @ref hs_close_stream(),
    /// since it is only when @ref hs_close_stream() is called that the EOD
    /// location is known. Zero if false, non-zero if true.
    ///
    /// Note: trailing `\b` word boundary assertions may also result in EOD
    /// matches as end-of-data can act as a word boundary.
    pub matches_at_eod: ::std::os::raw::c_char,
    /// Whether this expression can *only* produce matches at end of data (EOD).
    /// In streaming mode, all matches for this expression are raised during
    /// @ref hs_close_stream(). Zero if false, non-zero if true.
    pub matches_only_at_eod: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hs_expr_info() {
    assert_eq!(
        ::std::mem::size_of::<hs_expr_info>(),
        12usize,
        concat!("Size of: ", stringify!(hs_expr_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_expr_info>(),
        4usize,
        concat!("Alignment of ", stringify!(hs_expr_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_info>())).min_width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_info>())).max_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_info>())).unordered_matches as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(unordered_matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_info>())).matches_at_eod as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(matches_at_eod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_info>())).matches_only_at_eod as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(matches_only_at_eod)
        )
    );
}
pub type hs_expr_info_t = hs_expr_info;
/// A structure containing additional parameters related to an expression,
/// passed in at build time to @ref hs_compile_ext_multi() or @ref
/// hs_expression_ext_info.
///
/// These parameters allow the set of matches produced by a pattern to be
/// constrained at compile time, rather than relying on the application to
/// process unwanted matches at runtime.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_expr_ext {
    /// Flags governing which parts of this structure are to be used by the
    /// compiler. See @ref HS_EXT_FLAG.
    pub flags: ::std::os::raw::c_ulonglong,
    /// The minimum end offset in the data stream at which this expression
    /// should match successfully. To use this parameter, set the
    /// @ref HS_EXT_FLAG_MIN_OFFSET flag in the hs_expr_ext::flags field.
    pub min_offset: ::std::os::raw::c_ulonglong,
    /// The maximum end offset in the data stream at which this expression
    /// should match successfully. To use this parameter, set the
    /// @ref HS_EXT_FLAG_MAX_OFFSET flag in the hs_expr_ext::flags field.
    pub max_offset: ::std::os::raw::c_ulonglong,
    /// The minimum match length (from start to end) required to successfully
    /// match this expression. To use this parameter, set the
    /// @ref HS_EXT_FLAG_MIN_LENGTH flag in the hs_expr_ext::flags field.
    pub min_length: ::std::os::raw::c_ulonglong,
    /// Allow patterns to approximately match within this edit distance. To use
    /// this parameter, set the @ref HS_EXT_FLAG_EDIT_DISTANCE flag in the
    /// hs_expr_ext::flags field.
    pub edit_distance: ::std::os::raw::c_uint,
    /// Allow patterns to approximately match within this Hamming distance. To
    /// use this parameter, set the @ref HS_EXT_FLAG_HAMMING_DISTANCE flag in the
    /// hs_expr_ext::flags field.
    pub hamming_distance: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hs_expr_ext() {
    assert_eq!(
        ::std::mem::size_of::<hs_expr_ext>(),
        40usize,
        concat!("Size of: ", stringify!(hs_expr_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_expr_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_expr_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_ext>())).flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_ext>())).min_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_ext),
            "::",
            stringify!(min_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_ext>())).max_offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_ext),
            "::",
            stringify!(max_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_ext>())).min_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_ext),
            "::",
            stringify!(min_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_ext>())).edit_distance as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_ext),
            "::",
            stringify!(edit_distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hs_expr_ext>())).hamming_distance as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_ext),
            "::",
            stringify!(hamming_distance)
        )
    );
}
pub type hs_expr_ext_t = hs_expr_ext;
extern "C" {
    /// The basic regular expression compiler.
    ///
    /// This is the function call with which an expression is compiled into a
    /// Hyperscan database which can be passed to the runtime functions (such as
    /// @ref hs_scan(), @ref hs_open_stream(), etc.)
    ///
    /// @param expression
    /// The NULL-terminated expression to parse. Note that this string must
    /// represent ONLY the pattern to be matched, with no delimiters or flags;
    /// any global flags should be specified with the @p flags argument. For
    /// example, the expression `/abc?def/i` should be compiled by providing
    /// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
    /// flags.
    ///
    /// @param flags
    /// Flags which modify the behaviour of the expression. Multiple flags may
    /// be used by ORing them together. Valid values are:
    /// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
    /// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
    /// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
    /// - HS_FLAG_SINGLEMATCH - Only one match will be generated for the
    /// expression per stream.
    /// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
    /// empty string, such as `.*`.
    /// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
    /// - HS_FLAG_UCP - Use Unicode properties for character classes.
    /// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
    /// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
    /// when a match is found.
    ///
    /// @param mode
    /// Compiler mode flags that affect the database as a whole. One of @ref
    /// HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
    /// supplied, to select between the generation of a streaming, block or
    /// vectored database. In addition, other flags (beginning with HS_MODE_)
    /// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
    /// more details.
    ///
    /// @param platform
    /// If not NULL, the platform structure is used to determine the target
    /// platform for the database. If NULL, a database suitable for running
    /// on the current host platform is produced.
    ///
    /// @param db
    /// On success, a pointer to the generated database will be returned in
    /// this parameter, or NULL on failure. The caller is responsible for
    /// deallocating the buffer using the @ref hs_free_database() function.
    ///
    /// @param error
    /// If the compile fails, a pointer to a @ref hs_compile_error_t will be
    /// returned, providing details of the error condition. The caller is
    /// responsible for deallocating the buffer using the @ref
    /// hs_free_compile_error() function.
    ///
    /// @return
    /// @ref HS_SUCCESS is returned on successful compilation; @ref
    /// HS_COMPILER_ERROR on failure, with details provided in the error
    /// parameter.
    pub fn hs_compile(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    /// The multiple regular expression compiler.
    ///
    /// This is the function call with which a set of expressions is compiled into a
    /// database which can be passed to the runtime functions (such as @ref
    /// hs_scan(), @ref hs_open_stream(), etc.) Each expression can be labelled with
    /// a unique integer which is passed into the match callback to identify the
    /// pattern that has matched.
    ///
    /// @param expressions
    /// Array of NULL-terminated expressions to compile. Note that (as for @ref
    /// hs_compile()) these strings must contain only the pattern to be
    /// matched, with no delimiters or flags. For example, the expression
    /// `/abc?def/i` should be compiled by providing `abc?def` as the first
    /// string in the @p expressions array, and @ref HS_FLAG_CASELESS as the
    /// first value in the @p flags array.
    ///
    /// @param flags
    /// Array of flags which modify the behaviour of each expression. Multiple
    /// flags may be used by ORing them together.  Specifying the NULL pointer
    /// in place of an array will set the flags value for all patterns to zero.
    /// Valid values are:
    /// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
    /// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
    /// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
    /// - HS_FLAG_SINGLEMATCH - Only one match will be generated by patterns
    /// with this match id per stream.
    /// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
    /// empty string, such as `.*`.
    /// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
    /// - HS_FLAG_UCP - Use Unicode properties for character classes.
    /// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
    /// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
    /// when a match is found.
    ///
    /// @param ids
    /// An array of integers specifying the ID number to be associated with the
    /// corresponding pattern in the expressions array. Specifying the NULL
    /// pointer in place of an array will set the ID value for all patterns to
    /// zero.
    ///
    /// @param elements
    /// The number of elements in the input arrays.
    ///
    /// @param mode
    /// Compiler mode flags that affect the database as a whole. One of @ref
    /// HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
    /// supplied, to select between the generation of a streaming, block or
    /// vectored database. In addition, other flags (beginning with HS_MODE_)
    /// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
    /// more details.
    ///
    /// @param platform
    /// If not NULL, the platform structure is used to determine the target
    /// platform for the database. If NULL, a database suitable for running
    /// on the current host platform is produced.
    ///
    /// @param db
    /// On success, a pointer to the generated database will be returned in
    /// this parameter, or NULL on failure. The caller is responsible for
    /// deallocating the buffer using the @ref hs_free_database() function.
    ///
    /// @param error
    /// If the compile fails, a pointer to a @ref hs_compile_error_t will be
    /// returned, providing details of the error condition. The caller is
    /// responsible for deallocating the buffer using the @ref
    /// hs_free_compile_error() function.
    ///
    /// @return
    /// @ref HS_SUCCESS is returned on successful compilation; @ref
    /// HS_COMPILER_ERROR on failure, with details provided in the @p error
    /// parameter.
    ///
    pub fn hs_compile_multi(
        expressions: *const *const ::std::os::raw::c_char,
        flags: *const ::std::os::raw::c_uint,
        ids: *const ::std::os::raw::c_uint,
        elements: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    /// The multiple regular expression compiler with extended parameter support.
    ///
    /// This function call compiles a group of expressions into a database in the
    /// same way as @ref hs_compile_multi(), but allows additional parameters to be
    /// specified via an @ref hs_expr_ext_t structure per expression.
    ///
    /// @param expressions
    /// Array of NULL-terminated expressions to compile. Note that (as for @ref
    /// hs_compile()) these strings must contain only the pattern to be
    /// matched, with no delimiters or flags. For example, the expression
    /// `/abc?def/i` should be compiled by providing `abc?def` as the first
    /// string in the @p expressions array, and @ref HS_FLAG_CASELESS as the
    /// first value in the @p flags array.
    ///
    /// @param flags
    /// Array of flags which modify the behaviour of each expression. Multiple
    /// flags may be used by ORing them together. Specifying the NULL pointer
    /// in place of an array will set the flags value for all patterns to zero.
    /// Valid values are:
    /// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
    /// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
    /// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
    /// - HS_FLAG_SINGLEMATCH - Only one match will be generated by patterns
    /// with this match id per stream.
    /// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
    /// empty string, such as `.*`.
    /// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
    /// - HS_FLAG_UCP - Use Unicode properties for character classes.
    /// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
    /// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
    /// when a match is found.
    ///
    /// @param ids
    /// An array of integers specifying the ID number to be associated with the
    /// corresponding pattern in the expressions array. Specifying the NULL
    /// pointer in place of an array will set the ID value for all patterns to
    /// zero.
    ///
    /// @param ext
    /// An array of pointers to filled @ref hs_expr_ext_t structures that
    /// define extended behaviour for each pattern. NULL may be specified if no
    /// extended behaviour is needed for an individual pattern, or in place of
    /// the whole array if it is not needed for any expressions. Memory used by
    /// these structures must be both allocated and freed by the caller.
    ///
    /// @param elements
    /// The number of elements in the input arrays.
    ///
    /// @param mode
    /// Compiler mode flags that affect the database as a whole. One of @ref
    /// HS_MODE_STREAM, @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
    /// supplied, to select between the generation of a streaming, block or
    /// vectored database. In addition, other flags (beginning with HS_MODE_)
    /// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
    /// more details.
    ///
    /// @param platform
    /// If not NULL, the platform structure is used to determine the target
    /// platform for the database. If NULL, a database suitable for running
    /// on the current host platform is produced.
    ///
    /// @param db
    /// On success, a pointer to the generated database will be returned in
    /// this parameter, or NULL on failure. The caller is responsible for
    /// deallocating the buffer using the @ref hs_free_database() function.
    ///
    /// @param error
    /// If the compile fails, a pointer to a @ref hs_compile_error_t will be
    /// returned, providing details of the error condition. The caller is
    /// responsible for deallocating the buffer using the @ref
    /// hs_free_compile_error() function.
    ///
    /// @return
    /// @ref HS_SUCCESS is returned on successful compilation; @ref
    /// HS_COMPILER_ERROR on failure, with details provided in the @p error
    /// parameter.
    ///
    pub fn hs_compile_ext_multi(
        expressions: *const *const ::std::os::raw::c_char,
        flags: *const ::std::os::raw::c_uint,
        ids: *const ::std::os::raw::c_uint,
        ext: *const *const hs_expr_ext_t,
        elements: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    /// Free an error structure generated by @ref hs_compile(), @ref
    /// hs_compile_multi() or @ref hs_compile_ext_multi().
    ///
    /// @param error
    /// The @ref hs_compile_error_t to be freed. NULL may also be safely
    /// provided.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_free_compile_error(error: *mut hs_compile_error_t) -> hs_error_t;
}
extern "C" {
    /// Utility function providing information about a regular expression. The
    /// information provided in @ref hs_expr_info_t includes the minimum and maximum
    /// width of a pattern match.
    ///
    /// Note: successful analysis of an expression with this function does not imply
    /// that compilation of the same expression (via @ref hs_compile(), @ref
    /// hs_compile_multi() or @ref hs_compile_ext_multi()) would succeed. This
    /// function may return @ref HS_SUCCESS for regular expressions that Hyperscan
    /// cannot compile.
    ///
    /// Note: some per-pattern flags (such as @ref HS_FLAG_ALLOWEMPTY, @ref
    /// HS_FLAG_SOM_LEFTMOST) are accepted by this call, but as they do not affect
    /// the properties returned in the @ref hs_expr_info_t structure, they will not
    /// affect the outcome of this function.
    ///
    /// @param expression
    /// The NULL-terminated expression to parse. Note that this string must
    /// represent ONLY the pattern to be matched, with no delimiters or flags;
    /// any global flags should be specified with the @p flags argument.  For
    /// example, the expression `/abc?def/i` should be compiled by providing
    /// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
    /// flags.
    ///
    /// @param flags
    /// Flags which modify the behaviour of the expression. Multiple flags may
    /// be used by ORing them together. Valid values are:
    /// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
    /// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
    /// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
    /// - HS_FLAG_SINGLEMATCH - Only one match will be generated by the
    /// expression per stream.
    /// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
    /// empty string, such as `.*`.
    /// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
    /// - HS_FLAG_UCP - Use Unicode properties for character classes.
    /// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
    /// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
    /// when a match is found.
    ///
    /// @param info
    /// On success, a pointer to the pattern information will be returned in
    /// this parameter, or NULL on failure. This structure is allocated using
    /// the allocator supplied in @ref hs_set_allocator() (or malloc() if no
    /// allocator was set) and should be freed by the caller.
    ///
    /// @param error
    /// If the call fails, a pointer to a @ref hs_compile_error_t will be
    /// returned, providing details of the error condition. The caller is
    /// responsible for deallocating the buffer using the @ref
    /// hs_free_compile_error() function.
    ///
    /// @return
    /// @ref HS_SUCCESS is returned on successful compilation; @ref
    /// HS_COMPILER_ERROR on failure, with details provided in the error
    /// parameter.
    pub fn hs_expression_info(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        info: *mut *mut hs_expr_info_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    /// Utility function providing information about a regular expression, with
    /// extended parameter support. The information provided in @ref hs_expr_info_t
    /// includes the minimum and maximum width of a pattern match.
    ///
    /// Note: successful analysis of an expression with this function does not imply
    /// that compilation of the same expression (via @ref hs_compile(), @ref
    /// hs_compile_multi() or @ref hs_compile_ext_multi()) would succeed. This
    /// function may return @ref HS_SUCCESS for regular expressions that Hyperscan
    /// cannot compile.
    ///
    /// Note: some per-pattern flags (such as @ref HS_FLAG_ALLOWEMPTY, @ref
    /// HS_FLAG_SOM_LEFTMOST) are accepted by this call, but as they do not affect
    /// the properties returned in the @ref hs_expr_info_t structure, they will not
    /// affect the outcome of this function.
    ///
    /// @param expression
    /// The NULL-terminated expression to parse. Note that this string must
    /// represent ONLY the pattern to be matched, with no delimiters or flags;
    /// any global flags should be specified with the @p flags argument.  For
    /// example, the expression `/abc?def/i` should be compiled by providing
    /// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
    /// flags.
    ///
    /// @param flags
    /// Flags which modify the behaviour of the expression. Multiple flags may
    /// be used by ORing them together. Valid values are:
    /// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
    /// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
    /// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
    /// - HS_FLAG_SINGLEMATCH - Only one match will be generated by the
    /// expression per stream.
    /// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
    /// empty string, such as `.*`.
    /// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
    /// - HS_FLAG_UCP - Use Unicode properties for character classes.
    /// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
    /// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
    /// when a match is found.
    ///
    /// @param ext
    /// A pointer to a filled @ref hs_expr_ext_t structure that defines
    /// extended behaviour for this pattern. NULL may be specified if no
    /// extended parameters are needed.
    ///
    /// @param info
    /// On success, a pointer to the pattern information will be returned in
    /// this parameter, or NULL on failure. This structure is allocated using
    /// the allocator supplied in @ref hs_set_allocator() (or malloc() if no
    /// allocator was set) and should be freed by the caller.
    ///
    /// @param error
    /// If the call fails, a pointer to a @ref hs_compile_error_t will be
    /// returned, providing details of the error condition. The caller is
    /// responsible for deallocating the buffer using the @ref
    /// hs_free_compile_error() function.
    ///
    /// @return
    /// @ref HS_SUCCESS is returned on successful compilation; @ref
    /// HS_COMPILER_ERROR on failure, with details provided in the error
    /// parameter.
    pub fn hs_expression_ext_info(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        ext: *const hs_expr_ext_t,
        info: *mut *mut hs_expr_info_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    /// Populates the platform information based on the current host.
    ///
    /// @param platform
    /// On success, the pointed to structure is populated based on the current
    /// host.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_populate_platform(platform: *mut hs_platform_info_t) -> hs_error_t;
}
/// Definition of the stream identifier type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_stream {
    _unused: [u8; 0],
}
/// The stream identifier returned by @ref hs_open_stream().
pub type hs_stream_t = hs_stream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_scratch {
    _unused: [u8; 0],
}
/// A Hyperscan scratch space.
pub type hs_scratch_t = hs_scratch;
/// Definition of the match event callback function type.
///
/// A callback function matching the defined type must be provided by the
/// application calling the @ref hs_scan(), @ref hs_scan_vector() or @ref
/// hs_scan_stream() functions (or other streaming calls which can produce
/// matches).
///
/// This callback function will be invoked whenever a match is located in the
/// target data during the execution of a scan. The details of the match are
/// passed in as parameters to the callback function, and the callback function
/// should return a value indicating whether or not matching should continue on
/// the target data. If no callbacks are desired from a scan call, NULL may be
/// provided in order to suppress match production.
///
/// This callback function should not attempt to call Hyperscan API functions on
/// the same stream nor should it attempt to reuse the scratch space allocated
/// for the API calls that caused it to be triggered. Making another call to the
/// Hyperscan library with completely independent parameters should work (for
/// example, scanning a different database in a new stream and with new scratch
/// space), but reusing data structures like stream state and/or scratch space
/// will produce undefined behavior.
///
/// @param id
/// The ID number of the expression that matched. If the expression was a
/// single expression compiled with @ref hs_compile(), this value will be
/// zero.
///
/// @param from
/// - If a start of match flag is enabled for the current pattern, this
/// argument will be set to the start of match for the pattern assuming
/// that that start of match value lies within the current 'start of match
/// horizon' chosen by one of the SOM_HORIZON mode flags.
///
/// - If the start of match value lies outside this horizon (possible only
/// when the SOM_HORIZON value is not @ref HS_MODE_SOM_HORIZON_LARGE),
/// the @p from value will be set to @ref HS_OFFSET_PAST_HORIZON.
///
/// - This argument will be set to zero if the Start of Match flag is not
/// enabled for the given pattern.
///
/// @param to
/// The offset after the last byte that matches the expression.
///
/// @param flags
/// This is provided for future use and is unused at present.
///
/// @param context
/// The pointer supplied by the user to the @ref hs_scan(), @ref
/// hs_scan_vector() or @ref hs_scan_stream() function.
///
/// @return
/// Non-zero if the matching should cease, else zero. If scanning is
/// performed in streaming mode and a non-zero value is returned, any
/// subsequent calls to @ref hs_scan_stream() for that stream will
/// immediately return with @ref HS_SCAN_TERMINATED.
pub type match_event_handler = ::std::option::Option<
    unsafe extern "C" fn(
        id: ::std::os::raw::c_uint,
        from: ::std::os::raw::c_ulonglong,
        to: ::std::os::raw::c_ulonglong,
        flags: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Open and initialise a stream.
    ///
    /// @param db
    /// A compiled pattern database.
    ///
    /// @param flags
    /// Flags modifying the behaviour of the stream. This parameter is provided
    /// for future use and is unused at present.
    ///
    /// @param stream
    /// On success, a pointer to the generated @ref hs_stream_t will be
    /// returned; NULL on failure.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_open_stream(
        db: *const hs_database_t,
        flags: ::std::os::raw::c_uint,
        stream: *mut *mut hs_stream_t,
    ) -> hs_error_t;
}
extern "C" {
    /// Write data to be scanned to the opened stream.
    ///
    /// This is the function call in which the actual pattern matching takes place
    /// as data is written to the stream. Matches will be returned via the @ref
    /// match_event_handler callback supplied.
    ///
    /// @param id
    /// The stream ID (returned by @ref hs_open_stream()) to which the data
    /// will be written.
    ///
    /// @param data
    /// Pointer to the data to be scanned.
    ///
    /// @param length
    /// The number of bytes to scan.
    ///
    /// @param flags
    /// Flags modifying the behaviour of the stream. This parameter is provided
    /// for future use and is unused at present.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch().
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param ctxt
    /// The user defined pointer which will be passed to the callback function
    /// when a match occurs.
    ///
    /// @return
    /// Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the
    /// match callback indicated that scanning should stop; other values on
    /// error.
    pub fn hs_scan_stream(
        id: *mut hs_stream_t,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        ctxt: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// Close a stream.
    ///
    /// This function completes matching on the given stream and frees the memory
    /// associated with the stream state. After this call, the stream pointed to by
    /// @p id is invalid and can no longer be used. To reuse the stream state after
    /// completion, rather than closing it, the @ref hs_reset_stream function can be
    /// used.
    ///
    /// This function must be called for any stream created with @ref
    /// hs_open_stream(), even if scanning has been terminated by a non-zero return
    /// from the match callback function.
    ///
    /// Note: This operation may result in matches being returned (via calls to the
    /// match event callback) for expressions anchored to the end of the data stream
    /// (for example, via the use of the `$` meta-character). If these matches are
    /// not desired, NULL may be provided as the @ref match_event_handler callback.
    ///
    /// If NULL is provided as the @ref match_event_handler callback, it is
    /// permissible to provide a NULL scratch.
    ///
    /// @param id
    /// The stream ID returned by @ref hs_open_stream().
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
    /// allowed to be NULL only if the @p onEvent callback is also NULL.
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param ctxt
    /// The user defined pointer which will be passed to the callback function
    /// when a match occurs.
    ///
    /// @return
    /// Returns @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_close_stream(
        id: *mut hs_stream_t,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        ctxt: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// Reset a stream to an initial state.
    ///
    /// Conceptually, this is equivalent to performing @ref hs_close_stream() on the
    /// given stream, followed by a @ref hs_open_stream(). This new stream replaces
    /// the original stream in memory, avoiding the overhead of freeing the old
    /// stream and allocating the new one.
    ///
    /// Note: This operation may result in matches being returned (via calls to the
    /// match event callback) for expressions anchored to the end of the original
    /// data stream (for example, via the use of the `$` meta-character). If these
    /// matches are not desired, NULL may be provided as the @ref match_event_handler
    /// callback.
    ///
    /// Note: the stream will also be tied to the same database.
    ///
    /// @param id
    /// The stream (as created by @ref hs_open_stream()) to be replaced.
    ///
    /// @param flags
    /// Flags modifying the behaviour of the stream. This parameter is provided
    /// for future use and is unused at present.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
    /// allowed to be NULL only if the @p onEvent callback is also NULL.
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param context
    /// The user defined pointer which will be passed to the callback function
    /// when a match occurs.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_reset_stream(
        id: *mut hs_stream_t,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// Duplicate the given stream. The new stream will have the same state as the
    /// original including the current stream offset.
    ///
    /// @param to_id
    /// On success, a pointer to the new, copied @ref hs_stream_t will be
    /// returned; NULL on failure.
    ///
    /// @param from_id
    /// The stream (as created by @ref hs_open_stream()) to be copied.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_copy_stream(to_id: *mut *mut hs_stream_t, from_id: *const hs_stream_t) -> hs_error_t;
}
extern "C" {
    /// Duplicate the given 'from' stream state onto the 'to' stream. The 'to' stream
    /// will first be reset (reporting any EOD matches if a non-NULL @p onEvent
    /// callback handler is provided).
    ///
    /// Note: the 'to' stream and the 'from' stream must be open against the same
    /// database.
    ///
    /// @param to_id
    /// On success, a pointer to the new, copied @ref hs_stream_t will be
    /// returned; NULL on failure.
    ///
    /// @param from_id
    /// The stream (as created by @ref hs_open_stream()) to be copied.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
    /// allowed to be NULL only if the @p onEvent callback is also NULL.
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param context
    /// The user defined pointer which will be passed to the callback function
    /// when a match occurs.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_reset_and_copy_stream(
        to_id: *mut hs_stream_t,
        from_id: *const hs_stream_t,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// Creates a compressed representation of the provided stream in the buffer
    /// provided. This compressed representation can be converted back into a stream
    /// state by using @ref hs_expand_stream() or @ref hs_reset_and_expand_stream().
    /// The size of the compressed representation will be placed into @p used_space.
    ///
    /// If there is not sufficient space in the buffer to hold the compressed
    /// representation, @ref HS_INSUFFICIENT_SPACE will be returned and @p used_space
    /// will be populated with the amount of space required.
    ///
    /// Note: this function does not close the provided stream, you may continue to
    /// use the stream or to free it with @ref hs_close_stream().
    ///
    /// @param stream
    /// The stream (as created by @ref hs_open_stream()) to be compressed.
    ///
    /// @param buf
    /// Buffer to write the compressed representation into. Note: if the call is
    /// just being used to determine the amount of space required, it is allowed
    /// to pass NULL here and @p buf_space as 0.
    ///
    /// @param buf_space
    /// The number of bytes in @p buf. If buf_space is too small, the call will
    /// fail with @ref HS_INSUFFICIENT_SPACE.
    ///
    /// @param used_space
    /// Pointer to where the amount of used space will be written to. The used
    /// buffer space is always less than or equal to @p buf_space. If the call
    /// fails with @ref HS_INSUFFICIENT_SPACE, this pointer will be used to
    /// write out the amount of buffer space required.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, @ref HS_INSUFFICIENT_SPACE if the provided
    /// buffer is too small.
    pub fn hs_compress_stream(
        stream: *const hs_stream_t,
        buf: *mut ::std::os::raw::c_char,
        buf_space: usize,
        used_space: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    /// Decompresses a compressed representation created by @ref hs_compress_stream()
    /// into a new stream.
    ///
    /// Note: @p buf must correspond to a complete compressed representation created
    /// by @ref hs_compress_stream() of a stream that was opened against @p db. It is
    /// not always possible to detect misuse of this API and behaviour is undefined
    /// if these properties are not satisfied.
    ///
    /// @param db
    /// The compiled pattern database that the compressed stream was opened
    /// against.
    ///
    /// @param stream
    /// On success, a pointer to the expanded @ref hs_stream_t will be
    /// returned; NULL on failure.
    ///
    /// @param buf
    /// A compressed representation of a stream. These compressed forms are
    /// created by @ref hs_compress_stream().
    ///
    /// @param buf_size
    /// The size in bytes of the compressed representation.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_expand_stream(
        db: *const hs_database_t,
        stream: *mut *mut hs_stream_t,
        buf: *const ::std::os::raw::c_char,
        buf_size: usize,
    ) -> hs_error_t;
}
extern "C" {
    /// Decompresses a compressed representation created by @ref hs_compress_stream()
    /// on top of the 'to' stream. The 'to' stream will first be reset (reporting
    /// any EOD matches if a non-NULL @p onEvent callback handler is provided).
    ///
    /// Note: the 'to' stream must be opened against the same database as the
    /// compressed stream.
    ///
    /// Note: @p buf must correspond to a complete compressed representation created
    /// by @ref hs_compress_stream() of a stream that was opened against @p db. It is
    /// not always possible to detect misuse of this API and behaviour is undefined
    /// if these properties are not satisfied.
    ///
    /// @param to_stream
    /// A pointer to a valid stream state. A pointer to the expanded @ref
    /// hs_stream_t will be returned; NULL on failure.
    ///
    /// @param buf
    /// A compressed representation of a stream. These compressed forms are
    /// created by @ref hs_compress_stream().
    ///
    /// @param buf_size
    /// The size in bytes of the compressed representation.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
    /// allowed to be NULL only if the @p onEvent callback is also NULL.
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param context
    /// The user defined pointer which will be passed to the callback function
    /// when a match occurs.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_reset_and_expand_stream(
        to_stream: *mut hs_stream_t,
        buf: *const ::std::os::raw::c_char,
        buf_size: usize,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// The block (non-streaming) regular expression scanner.
    ///
    /// This is the function call in which the actual pattern matching takes place
    /// for block-mode pattern databases.
    ///
    /// @param db
    /// A compiled pattern database.
    ///
    /// @param data
    /// Pointer to the data to be scanned.
    ///
    /// @param length
    /// The number of bytes to scan.
    ///
    /// @param flags
    /// Flags modifying the behaviour of this function. This parameter is
    /// provided for future use and is unused at present.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch() for this
    /// database.
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param context
    /// The user defined pointer which will be passed to the callback function.
    ///
    /// @return
    /// Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the
    /// match callback indicated that scanning should stop; other values on
    /// error.
    pub fn hs_scan(
        db: *const hs_database_t,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// The vectored regular expression scanner.
    ///
    /// This is the function call in which the actual pattern matching takes place
    /// for vectoring-mode pattern databases.
    ///
    /// @param db
    /// A compiled pattern database.
    ///
    /// @param data
    /// An array of pointers to the data blocks to be scanned.
    ///
    /// @param length
    /// An array of lengths (in bytes) of each data block to scan.
    ///
    /// @param count
    /// Number of data blocks to scan. This should correspond to the size of
    /// of the @p data and @p length arrays.
    ///
    /// @param flags
    /// Flags modifying the behaviour of this function. This parameter is
    /// provided for future use and is unused at present.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch() for
    /// this database.
    ///
    /// @param onEvent
    /// Pointer to a match event callback function. If a NULL pointer is given,
    /// no matches will be returned.
    ///
    /// @param context
    /// The user defined pointer which will be passed to the callback function.
    ///
    /// @return
    /// Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the match
    /// callback indicated that scanning should stop; other values on error.
    pub fn hs_scan_vector(
        db: *const hs_database_t,
        data: *const *const ::std::os::raw::c_char,
        length: *const ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    /// Allocate a "scratch" space for use by Hyperscan.
    ///
    /// This is required for runtime use, and one scratch space per thread, or
    /// concurrent caller, is required. Any allocator callback set by @ref
    /// hs_set_scratch_allocator() or @ref hs_set_allocator() will be used by this
    /// function.
    ///
    /// @param db
    /// The database, as produced by @ref hs_compile().
    ///
    /// @param scratch
    /// On first allocation, a pointer to NULL should be provided so a new
    /// scratch can be allocated. If a scratch block has been previously
    /// allocated, then a pointer to it should be passed back in to see if it
    /// is valid for this database block. If a new scratch block is required,
    /// the original will be freed and the new one returned, otherwise the
    /// previous scratch block will be returned. On success, the scratch block
    /// will be suitable for use with the provided database in addition to any
    /// databases that original scratch space was suitable for.
    ///
    /// @return
    /// @ref HS_SUCCESS on successful allocation; @ref HS_NOMEM if the
    /// allocation fails.  Other errors may be returned if invalid parameters
    /// are specified.
    pub fn hs_alloc_scratch(db: *const hs_database_t, scratch: *mut *mut hs_scratch_t) -> hs_error_t;
}
extern "C" {
    /// Allocate a scratch space that is a clone of an existing scratch space.
    ///
    /// This is useful when multiple concurrent threads will be using the same set
    /// of compiled databases, and another scratch space is required. Any allocator
    /// callback set by @ref hs_set_scratch_allocator() or @ref hs_set_allocator()
    /// will be used by this function.
    ///
    /// @param src
    /// The existing @ref hs_scratch_t to be cloned.
    ///
    /// @param dest
    /// A pointer to the new scratch space will be returned here.
    ///
    /// @return
    /// @ref HS_SUCCESS on success; @ref HS_NOMEM if the allocation fails.
    /// Other errors may be returned if invalid parameters are specified.
    pub fn hs_clone_scratch(src: *const hs_scratch_t, dest: *mut *mut hs_scratch_t) -> hs_error_t;
}
extern "C" {
    /// Provides the size of the given scratch space.
    ///
    /// @param scratch
    /// A per-thread scratch space allocated by @ref hs_alloc_scratch() or @ref
    /// hs_clone_scratch().
    ///
    /// @param scratch_size
    /// On success, the size of the scratch space in bytes is placed in this
    /// parameter.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_scratch_size(scratch: *const hs_scratch_t, scratch_size: *mut usize) -> hs_error_t;
}
extern "C" {
    /// Free a scratch block previously allocated by @ref hs_alloc_scratch() or @ref
    /// hs_clone_scratch().
    ///
    /// The free callback set by @ref hs_set_scratch_allocator() or @ref
    /// hs_set_allocator() will be used by this function.
    ///
    /// @param scratch
    /// The scratch block to be freed. NULL may also be safely provided.
    ///
    /// @return
    /// @ref HS_SUCCESS on success, other values on failure.
    pub fn hs_free_scratch(scratch: *mut hs_scratch_t) -> hs_error_t;
}
