/* automatically generated by rust-bindgen */

# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_database { _unused : [ u8 ; 0 ] , } 
 /// A Hyperscan pattern database.
///
/// Generated by one of the Hyperscan compiler functions:
/// - @ref hs_compile()
/// - @ref hs_compile_multi()
/// - @ref hs_compile_ext_multi() 
 pub type hs_database_t = hs_database ; 
 /// A type for errors returned by Hyperscan functions. 
 pub type hs_error_t = :: std :: os :: raw :: c_int ; extern "C" { 
 /// Free a compiled pattern database.
///
/// The free callback set by @ref hs_set_database_allocator() (or @ref
/// hs_set_allocator()) will be used by this function.
///
/// @param db
/// A compiled pattern database. NULL may also be safely provided, in which
/// case the function does nothing.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_free_database ( db : * mut hs_database_t ) -> hs_error_t ; } extern "C" { 
 /// Serialize a pattern database to a stream of bytes.
///
/// The allocator callback set by @ref hs_set_misc_allocator() (or @ref
/// hs_set_allocator()) will be used by this function.
///
/// @param db
/// A compiled pattern database.
///
/// @param bytes
/// On success, a pointer to an array of bytes will be returned here.
/// These bytes can be subsequently relocated or written to disk. The
/// caller is responsible for freeing this block.
///
/// @param length
/// On success, the number of bytes in the generated byte array will be
/// returned here.
///
/// @return
/// @ref HS_SUCCESS on success, @ref HS_NOMEM if the byte array cannot be
/// allocated, other values may be returned if errors are detected. 
 pub fn hs_serialize_database ( db : * const hs_database_t , bytes : * mut * mut :: std :: os :: raw :: c_char , length : * mut usize ) -> hs_error_t ; } extern "C" { 
 /// Reconstruct a pattern database from a stream of bytes previously generated
/// by @ref hs_serialize_database().
///
/// This function will allocate sufficient space for the database using the
/// allocator set with @ref hs_set_database_allocator() (or @ref
/// hs_set_allocator()); to use a pre-allocated region of memory, use the @ref
/// hs_deserialize_database_at() function.
///
/// @param bytes
/// A byte array generated by @ref hs_serialize_database() representing a
/// compiled pattern database.
///
/// @param length
/// The length of the byte array generated by @ref hs_serialize_database().
/// This should be the same value as that returned by @ref
/// hs_serialize_database().
///
/// @param db
/// On success, a pointer to a newly allocated @ref hs_database_t will be
/// returned here. This database can then be used for scanning, and
/// eventually freed by the caller using @ref hs_free_database().
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_deserialize_database ( bytes : * const :: std :: os :: raw :: c_char , length : usize , db : * mut * mut hs_database_t ) -> hs_error_t ; } extern "C" { 
 /// Reconstruct a pattern database from a stream of bytes previously generated
/// by @ref hs_serialize_database() at a given memory location.
///
/// This function (unlike @ref hs_deserialize_database()) will write the
/// reconstructed database to the memory location given in the @p db parameter.
/// The amount of space required at this location can be determined with the
/// @ref hs_serialized_database_size() function.
///
/// @param bytes
/// A byte array generated by @ref hs_serialize_database() representing a
/// compiled pattern database.
///
/// @param length
/// The length of the byte array generated by @ref hs_serialize_database().
/// This should be the same value as that returned by @ref
/// hs_serialize_database().
///
/// @param db
/// Pointer to an 8-byte aligned block of memory of sufficient size to hold
/// the deserialized database. On success, the reconstructed database will
/// be written to this location. This database can then be used for pattern
/// matching. The user is responsible for freeing this memory; the @ref
/// hs_free_database() call should not be used.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_deserialize_database_at ( bytes : * const :: std :: os :: raw :: c_char , length : usize , db : * mut hs_database_t ) -> hs_error_t ; } extern "C" { 
 /// Provides the size of the stream state allocated by a single stream opened
/// against the given database.
///
/// @param database
/// Pointer to a compiled (streaming mode) pattern database.
///
/// @param stream_size
/// On success, the size in bytes of an individual stream opened against the
/// given database is placed in this parameter.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_stream_size ( database : * const hs_database_t , stream_size : * mut usize ) -> hs_error_t ; } extern "C" { 
 /// Provides the size of the given database in bytes.
///
/// @param database
/// Pointer to compiled pattern database.
///
/// @param database_size
/// On success, the size of the compiled database in bytes is placed in this
/// parameter.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_database_size ( database : * const hs_database_t , database_size : * mut usize ) -> hs_error_t ; } extern "C" { 
 /// Utility function for reporting the size that would be required by a
/// database if it were deserialized.
///
/// This can be used to allocate a shared memory region or other "special"
/// allocation prior to deserializing with the @ref hs_deserialize_database_at()
/// function.
///
/// @param bytes
/// Pointer to a byte array generated by @ref hs_serialize_database()
/// representing a compiled pattern database.
///
/// @param length
/// The length of the byte array generated by @ref hs_serialize_database().
/// This should be the same value as that returned by @ref
/// hs_serialize_database().
///
/// @param deserialized_size
/// On success, the size of the compiled database that would be generated
/// by @ref hs_deserialize_database_at() is returned here.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_serialized_database_size ( bytes : * const :: std :: os :: raw :: c_char , length : usize , deserialized_size : * mut usize ) -> hs_error_t ; } extern "C" { 
 /// Utility function providing information about a database.
///
/// @param database
/// Pointer to a compiled database.
///
/// @param info
/// On success, a string containing the version and platform information for
/// the supplied database is placed in the parameter. The string is
/// allocated using the allocator supplied in @ref hs_set_misc_allocator()
/// (or malloc() if no allocator was set) and should be freed by the caller.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_database_info ( database : * const hs_database_t , info : * mut * mut :: std :: os :: raw :: c_char ) -> hs_error_t ; } extern "C" { 
 /// Utility function providing information about a serialized database.
///
/// @param bytes
/// Pointer to a serialized database.
///
/// @param length
/// Length in bytes of the serialized database.
///
/// @param info
/// On success, a string containing the version and platform information
/// for the supplied serialized database is placed in the parameter. The
/// string is allocated using the allocator supplied in @ref
/// hs_set_misc_allocator() (or malloc() if no allocator was set) and
/// should be freed by the caller.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_serialized_database_info ( bytes : * const :: std :: os :: raw :: c_char , length : usize , info : * mut * mut :: std :: os :: raw :: c_char ) -> hs_error_t ; } 
 /// The type of the callback function that will be used by Hyperscan to allocate
/// more memory at runtime as required, for example in @ref hs_open_stream() to
/// allocate stream state.
///
/// If Hyperscan is to be used in a multi-threaded, or similarly concurrent
/// environment, the allocation function will need to be re-entrant, or
/// similarly safe for concurrent use.
///
/// @param size
/// The number of bytes to allocate.
/// @return
/// A pointer to the region of memory allocated, or NULL on error. 
 pub type hs_alloc_t = :: std :: option :: Option < unsafe extern "C" fn ( size : usize ) -> * mut :: std :: os :: raw :: c_void > ; 
 /// The type of the callback function that will be used by Hyperscan to free
/// memory regions previously allocated using the @ref hs_alloc_t function.
///
/// @param ptr
/// The region of memory to be freed. 
 pub type hs_free_t = :: std :: option :: Option < unsafe extern "C" fn ( ptr : * mut :: std :: os :: raw :: c_void ) > ; extern "C" { 
 /// Set the allocate and free functions used by Hyperscan for allocating
/// memory at runtime for stream state, scratch space, database bytecode,
/// and various other data structure returned by the Hyperscan API.
///
/// The function is equivalent to calling @ref hs_set_stream_allocator(),
/// @ref hs_set_scratch_allocator(), @ref hs_set_database_allocator() and
/// @ref hs_set_misc_allocator() with the provided parameters.
///
/// This call will override any previous allocators that have been set.
///
/// Note: there is no way to change the allocator used for temporary objects
/// created during the various compile calls (@ref hs_compile(), @ref
/// hs_compile_multi(), @ref hs_compile_ext_multi()).
///
/// @param alloc_func
/// A callback function pointer that allocates memory. This function must
/// return memory suitably aligned for the largest representable data type
/// on this platform.
///
/// @param free_func
/// A callback function pointer that frees allocated memory.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_set_allocator ( alloc_func : hs_alloc_t , free_func : hs_free_t ) -> hs_error_t ; } extern "C" { 
 /// Set the allocate and free functions used by Hyperscan for allocating memory
/// for database bytecode produced by the compile calls (@ref hs_compile(), @ref
/// hs_compile_multi(), @ref hs_compile_ext_multi()) and by database
/// deserialization (@ref hs_deserialize_database()).
///
/// If no database allocation functions are set, or if NULL is used in place of
/// both parameters, then memory allocation will default to standard methods
/// (such as the system malloc() and free() calls).
///
/// This call will override any previous database allocators that have been set.
///
/// Note: the database allocator may also be set by calling @ref
/// hs_set_allocator().
///
/// Note: there is no way to change how temporary objects created during the
/// various compile calls (@ref hs_compile(), @ref hs_compile_multi(), @ref
/// hs_compile_ext_multi()) are allocated.
///
/// @param alloc_func
/// A callback function pointer that allocates memory. This function must
/// return memory suitably aligned for the largest representable data type
/// on this platform.
///
/// @param free_func
/// A callback function pointer that frees allocated memory.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_set_database_allocator ( alloc_func : hs_alloc_t , free_func : hs_free_t ) -> hs_error_t ; } extern "C" { 
 /// Set the allocate and free functions used by Hyperscan for allocating memory
/// for items returned by the Hyperscan API such as @ref hs_compile_error_t, @ref
/// hs_expr_info_t and serialized databases.
///
/// If no misc allocation functions are set, or if NULL is used in place of both
/// parameters, then memory allocation will default to standard methods (such as
/// the system malloc() and free() calls).
///
/// This call will override any previous misc allocators that have been set.
///
/// Note: the misc allocator may also be set by calling @ref hs_set_allocator().
///
/// @param alloc_func
/// A callback function pointer that allocates memory. This function must
/// return memory suitably aligned for the largest representable data type
/// on this platform.
///
/// @param free_func
/// A callback function pointer that frees allocated memory.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_set_misc_allocator ( alloc_func : hs_alloc_t , free_func : hs_free_t ) -> hs_error_t ; } extern "C" { 
 /// Set the allocate and free functions used by Hyperscan for allocating memory
/// for scratch space by @ref hs_alloc_scratch() and @ref hs_clone_scratch().
///
/// If no scratch allocation functions are set, or if NULL is used in place of
/// both parameters, then memory allocation will default to standard methods
/// (such as the system malloc() and free() calls).
///
/// This call will override any previous scratch allocators that have been set.
///
/// Note: the scratch allocator may also be set by calling @ref
/// hs_set_allocator().
///
/// @param alloc_func
/// A callback function pointer that allocates memory. This function must
/// return memory suitably aligned for the largest representable data type
/// on this platform.
///
/// @param free_func
/// A callback function pointer that frees allocated memory.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_set_scratch_allocator ( alloc_func : hs_alloc_t , free_func : hs_free_t ) -> hs_error_t ; } extern "C" { 
 /// Set the allocate and free functions used by Hyperscan for allocating memory
/// for stream state by @ref hs_open_stream().
///
/// If no stream allocation functions are set, or if NULL is used in place of
/// both parameters, then memory allocation will default to standard methods
/// (such as the system malloc() and free() calls).
///
/// This call will override any previous stream allocators that have been set.
///
/// Note: the stream allocator may also be set by calling @ref
/// hs_set_allocator().
///
/// @param alloc_func
/// A callback function pointer that allocates memory. This function must
/// return memory suitably aligned for the largest representable data type
/// on this platform.
///
/// @param free_func
/// A callback function pointer that frees allocated memory.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_set_stream_allocator ( alloc_func : hs_alloc_t , free_func : hs_free_t ) -> hs_error_t ; } extern "C" { 
 /// Utility function for identifying this release version.
///
/// @return
/// A string containing the version number of this release build and the
/// date of the build. It is allocated statically, so it does not need to
/// be freed by the caller. 
 pub fn hs_version ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { 
 /// Utility function to test the current system architecture.
///
/// Hyperscan requires the Supplemental Streaming SIMD Extensions 3 instruction
/// set. This function can be called on any x86 platform to determine if the
/// system provides the required instruction set.
///
/// This function does not test for more advanced features if Hyperscan has
/// been built for a more specific architecture, for example the AVX2
/// instruction set.
///
/// @return
/// @ref HS_SUCCESS on success, @ref HS_ARCH_ERROR if system does not
/// support Hyperscan. 
 pub fn hs_valid_platform ( ) -> hs_error_t ; } 
 /// A type containing error details that is returned by the compile calls (@ref
/// hs_compile(), @ref hs_compile_multi() and @ref hs_compile_ext_multi()) on
/// failure. The caller may inspect the values returned in this type to
/// determine the cause of failure.
///
/// Common errors generated during the compile process include:
///
/// - *Invalid parameter*
///
/// An invalid argument was specified in the compile call.
///
/// - *Unrecognised flag*
///
/// An unrecognised value was passed in the flags argument.
///
/// - *Pattern matches empty buffer*
///
/// By default, Hyperscan only supports patterns that will *always*
/// consume at least one byte of input. Patterns that do not have this
/// property (such as `/(abc)?/`) will produce this error unless
/// the @ref HS_FLAG_ALLOWEMPTY flag is supplied. Note that such
/// patterns will produce a match for *every* byte when scanned.
///
/// - *Embedded anchors not supported*
///
/// Hyperscan only supports the use of anchor meta-characters (such as
/// `^` and `$`) in patterns where they could *only* match
/// at the start or end of a buffer. A pattern containing an embedded
/// anchor, such as `/abc^def/`, can never match, as there is no
/// way for `abc` to precede the start of the data stream.
///
/// - *Bounded repeat is too large*
///
/// The pattern contains a repeated construct with very large finite
/// bounds.
///
/// - *Unsupported component type*
///
/// An unsupported PCRE construct was used in the pattern.
///
/// - *Unable to generate bytecode*
///
/// This error indicates that Hyperscan was unable to compile a pattern
/// that is syntactically valid. The most common cause is a pattern that is
/// very long and complex or contains a large repeated subpattern.
///
/// - *Unable to allocate memory*
///
/// The library was unable to allocate temporary storage used during
/// compilation time.
///
/// - *Allocator returned misaligned memory*
///
/// The memory allocator (either malloc() or the allocator set with @ref
/// hs_set_allocator()) did not correctly return memory suitably aligned
/// for the largest representable data type on this platform.
///
/// - *Internal error*
///
/// An unexpected error occurred: if this error is reported, please contact
/// the Hyperscan team with a description of the situation. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_compile_error { 
 /// A human-readable error message describing the error. 
 pub message : * mut :: std :: os :: raw :: c_char , 
 /// The zero-based number of the expression that caused the error (if this
    /// can be determined). If the error is not specific to an expression, then
    /// this value will be less than zero. 
 pub expression : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_hs_compile_error ( ) { assert_eq ! ( :: std :: mem :: size_of :: < hs_compile_error > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( hs_compile_error ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < hs_compile_error > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( hs_compile_error ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_compile_error > ( ) ) ) . message as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( hs_compile_error ) , "::" , stringify ! ( message ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_compile_error > ( ) ) ) . expression as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( hs_compile_error ) , "::" , stringify ! ( expression ) ) ) ; } pub type hs_compile_error_t = hs_compile_error ; 
 /// A type containing information on the target platform which may optionally be
/// provided to the compile calls (@ref hs_compile(), @ref hs_compile_multi(),
/// @ref hs_compile_ext_multi()).
///
/// A hs_platform_info structure may be populated for the current platform by
/// using the @ref hs_populate_platform() call. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_platform_info { 
 /// Information about the target platform which may be used to guide the
    /// optimisation process of the compile.
    ///
    /// Use of this field does not limit the processors that the resulting
    /// database can run on, but may impact the performance of the resulting
    /// database. 
 pub tune : :: std :: os :: raw :: c_uint , 
 /// Relevant CPU features available on the target platform
    ///
    /// This value may be produced by combining HS_CPU_FEATURE_* flags (such as
    /// @ref HS_CPU_FEATURES_AVX2). Multiple CPU features may be or'ed together
    /// to produce the value. 
 pub cpu_features : :: std :: os :: raw :: c_ulonglong , 
 /// Reserved for future use. 
 pub reserved1 : :: std :: os :: raw :: c_ulonglong , 
 /// Reserved for future use. 
 pub reserved2 : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_hs_platform_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < hs_platform_info > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( hs_platform_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < hs_platform_info > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( hs_platform_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_platform_info > ( ) ) ) . tune as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( hs_platform_info ) , "::" , stringify ! ( tune ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_platform_info > ( ) ) ) . cpu_features as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( hs_platform_info ) , "::" , stringify ! ( cpu_features ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_platform_info > ( ) ) ) . reserved1 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( hs_platform_info ) , "::" , stringify ! ( reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_platform_info > ( ) ) ) . reserved2 as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( hs_platform_info ) , "::" , stringify ! ( reserved2 ) ) ) ; } pub type hs_platform_info_t = hs_platform_info ; 
 /// A type containing information related to an expression that is returned by
/// @ref hs_expression_info() or @ref hs_expression_ext_info. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_expr_info { 
 /// The minimum length in bytes of a match for the pattern.
    ///
    /// Note: in some cases when using advanced features to suppress matches
    /// (such as extended parameters or the @ref HS_FLAG_SINGLEMATCH flag) this
    /// may represent a conservative lower bound for the true minimum length of
    /// a match. 
 pub min_width : :: std :: os :: raw :: c_uint , 
 /// The maximum length in bytes of a match for the pattern. If the pattern
    /// has an unbounded maximum length, this will be set to the maximum value
    /// of an unsigned int (UINT_MAX).
    ///
    /// Note: in some cases when using advanced features to suppress matches
    /// (such as extended parameters or the @ref HS_FLAG_SINGLEMATCH flag) this
    /// may represent a conservative upper bound for the true maximum length of
    /// a match. 
 pub max_width : :: std :: os :: raw :: c_uint , 
 /// Whether this expression can produce matches that are not returned in
    /// order, such as those produced by assertions. Zero if false, non-zero if
    /// true. 
 pub unordered_matches : :: std :: os :: raw :: c_char , 
 /// Whether this expression can produce matches at end of data (EOD). In
    /// streaming mode, EOD matches are raised during @ref hs_close_stream(),
    /// since it is only when @ref hs_close_stream() is called that the EOD
    /// location is known. Zero if false, non-zero if true.
    ///
    /// Note: trailing `\b` word boundary assertions may also result in EOD
    /// matches as end-of-data can act as a word boundary. 
 pub matches_at_eod : :: std :: os :: raw :: c_char , 
 /// Whether this expression can *only* produce matches at end of data (EOD).
    /// In streaming mode, all matches for this expression are raised during
    /// @ref hs_close_stream(). Zero if false, non-zero if true. 
 pub matches_only_at_eod : :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_hs_expr_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < hs_expr_info > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( hs_expr_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < hs_expr_info > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( hs_expr_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_info > ( ) ) ) . min_width as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_info ) , "::" , stringify ! ( min_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_info > ( ) ) ) . max_width as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_info ) , "::" , stringify ! ( max_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_info > ( ) ) ) . unordered_matches as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_info ) , "::" , stringify ! ( unordered_matches ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_info > ( ) ) ) . matches_at_eod as * const _ as usize } , 9usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_info ) , "::" , stringify ! ( matches_at_eod ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_info > ( ) ) ) . matches_only_at_eod as * const _ as usize } , 10usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_info ) , "::" , stringify ! ( matches_only_at_eod ) ) ) ; } pub type hs_expr_info_t = hs_expr_info ; 
 /// A structure containing additional parameters related to an expression,
/// passed in at build time to @ref hs_compile_ext_multi() or @ref
/// hs_expression_ext_info.
///
/// These parameters allow the set of matches produced by a pattern to be
/// constrained at compile time, rather than relying on the application to
/// process unwanted matches at runtime. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_expr_ext { 
 /// Flags governing which parts of this structure are to be used by the
    /// compiler. See @ref HS_EXT_FLAG. 
 pub flags : :: std :: os :: raw :: c_ulonglong , 
 /// The minimum end offset in the data stream at which this expression
    /// should match successfully. To use this parameter, set the
    /// @ref HS_EXT_FLAG_MIN_OFFSET flag in the hs_expr_ext::flags field. 
 pub min_offset : :: std :: os :: raw :: c_ulonglong , 
 /// The maximum end offset in the data stream at which this expression
    /// should match successfully. To use this parameter, set the
    /// @ref HS_EXT_FLAG_MAX_OFFSET flag in the hs_expr_ext::flags field. 
 pub max_offset : :: std :: os :: raw :: c_ulonglong , 
 /// The minimum match length (from start to end) required to successfully
    /// match this expression. To use this parameter, set the
    /// @ref HS_EXT_FLAG_MIN_LENGTH flag in the hs_expr_ext::flags field. 
 pub min_length : :: std :: os :: raw :: c_ulonglong , 
 /// Allow patterns to approximately match within this edit distance. To use
    /// this parameter, set the @ref HS_EXT_FLAG_EDIT_DISTANCE flag in the
    /// hs_expr_ext::flags field. 
 pub edit_distance : :: std :: os :: raw :: c_uint , 
 /// Allow patterns to approximately match within this Hamming distance. To
    /// use this parameter, set the @ref HS_EXT_FLAG_HAMMING_DISTANCE flag in the
    /// hs_expr_ext::flags field. 
 pub hamming_distance : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_hs_expr_ext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < hs_expr_ext > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( hs_expr_ext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < hs_expr_ext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( hs_expr_ext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_ext > ( ) ) ) . flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_ext ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_ext > ( ) ) ) . min_offset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_ext ) , "::" , stringify ! ( min_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_ext > ( ) ) ) . max_offset as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_ext ) , "::" , stringify ! ( max_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_ext > ( ) ) ) . min_length as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_ext ) , "::" , stringify ! ( min_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_ext > ( ) ) ) . edit_distance as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_ext ) , "::" , stringify ! ( edit_distance ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < hs_expr_ext > ( ) ) ) . hamming_distance as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( hs_expr_ext ) , "::" , stringify ! ( hamming_distance ) ) ) ; } pub type hs_expr_ext_t = hs_expr_ext ; extern "C" { 
 /// The basic regular expression compiler.
///
/// This is the function call with which an expression is compiled into a
/// Hyperscan database which can be passed to the runtime functions (such as
/// @ref hs_scan(), @ref hs_open_stream(), etc.)
///
/// @param expression
/// The NULL-terminated expression to parse. Note that this string must
/// represent ONLY the pattern to be matched, with no delimiters or flags;
/// any global flags should be specified with the @p flags argument. For
/// example, the expression `/abc?def/i` should be compiled by providing
/// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
/// flags.
///
/// @param flags
/// Flags which modify the behaviour of the expression. Multiple flags may
/// be used by ORing them together. Valid values are:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated for the
/// expression per stream.
/// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
/// empty string, such as `.*`.
/// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
/// - HS_FLAG_UCP - Use Unicode properties for character classes.
/// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
/// - HS_FLAG_COMBINATION - Parse the expression in logical combination
/// syntax.
/// - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for
/// the sub-expressions in logical combinations.
///
/// @param mode
/// Compiler mode flags that affect the database as a whole. One of @ref
/// HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
/// supplied, to select between the generation of a streaming, block or
/// vectored database. In addition, other flags (beginning with HS_MODE_)
/// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
/// more details.
///
/// @param platform
/// If not NULL, the platform structure is used to determine the target
/// platform for the database. If NULL, a database suitable for running
/// on the current host platform is produced.
///
/// @param db
/// On success, a pointer to the generated database will be returned in
/// this parameter, or NULL on failure. The caller is responsible for
/// deallocating the buffer using the @ref hs_free_database() function.
///
/// @param error
/// If the compile fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the error
/// parameter. 
 pub fn hs_compile ( expression : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_uint , mode : :: std :: os :: raw :: c_uint , platform : * const hs_platform_info_t , db : * mut * mut hs_database_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// The multiple regular expression compiler.
///
/// This is the function call with which a set of expressions is compiled into a
/// database which can be passed to the runtime functions (such as @ref
/// hs_scan(), @ref hs_open_stream(), etc.) Each expression can be labelled with
/// a unique integer which is passed into the match callback to identify the
/// pattern that has matched.
///
/// @param expressions
/// Array of NULL-terminated expressions to compile. Note that (as for @ref
/// hs_compile()) these strings must contain only the pattern to be
/// matched, with no delimiters or flags. For example, the expression
/// `/abc?def/i` should be compiled by providing `abc?def` as the first
/// string in the @p expressions array, and @ref HS_FLAG_CASELESS as the
/// first value in the @p flags array.
///
/// @param flags
/// Array of flags which modify the behaviour of each expression. Multiple
/// flags may be used by ORing them together.  Specifying the NULL pointer
/// in place of an array will set the flags value for all patterns to zero.
/// Valid values are:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated by patterns
/// with this match id per stream.
/// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
/// empty string, such as `.*`.
/// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
/// - HS_FLAG_UCP - Use Unicode properties for character classes.
/// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
/// - HS_FLAG_COMBINATION - Parse the expression in logical combination
/// syntax.
/// - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for
/// the sub-expressions in logical combinations.
///
/// @param ids
/// An array of integers specifying the ID number to be associated with the
/// corresponding pattern in the expressions array. Specifying the NULL
/// pointer in place of an array will set the ID value for all patterns to
/// zero.
///
/// @param elements
/// The number of elements in the input arrays.
///
/// @param mode
/// Compiler mode flags that affect the database as a whole. One of @ref
/// HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
/// supplied, to select between the generation of a streaming, block or
/// vectored database. In addition, other flags (beginning with HS_MODE_)
/// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
/// more details.
///
/// @param platform
/// If not NULL, the platform structure is used to determine the target
/// platform for the database. If NULL, a database suitable for running
/// on the current host platform is produced.
///
/// @param db
/// On success, a pointer to the generated database will be returned in
/// this parameter, or NULL on failure. The caller is responsible for
/// deallocating the buffer using the @ref hs_free_database() function.
///
/// @param error
/// If the compile fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the @p error
/// parameter.
/// 
 pub fn hs_compile_multi ( expressions : * const * const :: std :: os :: raw :: c_char , flags : * const :: std :: os :: raw :: c_uint , ids : * const :: std :: os :: raw :: c_uint , elements : :: std :: os :: raw :: c_uint , mode : :: std :: os :: raw :: c_uint , platform : * const hs_platform_info_t , db : * mut * mut hs_database_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// The multiple regular expression compiler with extended parameter support.
///
/// This function call compiles a group of expressions into a database in the
/// same way as @ref hs_compile_multi(), but allows additional parameters to be
/// specified via an @ref hs_expr_ext_t structure per expression.
///
/// @param expressions
/// Array of NULL-terminated expressions to compile. Note that (as for @ref
/// hs_compile()) these strings must contain only the pattern to be
/// matched, with no delimiters or flags. For example, the expression
/// `/abc?def/i` should be compiled by providing `abc?def` as the first
/// string in the @p expressions array, and @ref HS_FLAG_CASELESS as the
/// first value in the @p flags array.
///
/// @param flags
/// Array of flags which modify the behaviour of each expression. Multiple
/// flags may be used by ORing them together. Specifying the NULL pointer
/// in place of an array will set the flags value for all patterns to zero.
/// Valid values are:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated by patterns
/// with this match id per stream.
/// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
/// empty string, such as `.*`.
/// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
/// - HS_FLAG_UCP - Use Unicode properties for character classes.
/// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
/// - HS_FLAG_COMBINATION - Parse the expression in logical combination
/// syntax.
/// - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for
/// the sub-expressions in logical combinations.
///
/// @param ids
/// An array of integers specifying the ID number to be associated with the
/// corresponding pattern in the expressions array. Specifying the NULL
/// pointer in place of an array will set the ID value for all patterns to
/// zero.
///
/// @param ext
/// An array of pointers to filled @ref hs_expr_ext_t structures that
/// define extended behaviour for each pattern. NULL may be specified if no
/// extended behaviour is needed for an individual pattern, or in place of
/// the whole array if it is not needed for any expressions. Memory used by
/// these structures must be both allocated and freed by the caller.
///
/// @param elements
/// The number of elements in the input arrays.
///
/// @param mode
/// Compiler mode flags that affect the database as a whole. One of @ref
/// HS_MODE_STREAM, @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
/// supplied, to select between the generation of a streaming, block or
/// vectored database. In addition, other flags (beginning with HS_MODE_)
/// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
/// more details.
///
/// @param platform
/// If not NULL, the platform structure is used to determine the target
/// platform for the database. If NULL, a database suitable for running
/// on the current host platform is produced.
///
/// @param db
/// On success, a pointer to the generated database will be returned in
/// this parameter, or NULL on failure. The caller is responsible for
/// deallocating the buffer using the @ref hs_free_database() function.
///
/// @param error
/// If the compile fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the @p error
/// parameter.
/// 
 pub fn hs_compile_ext_multi ( expressions : * const * const :: std :: os :: raw :: c_char , flags : * const :: std :: os :: raw :: c_uint , ids : * const :: std :: os :: raw :: c_uint , ext : * const * const hs_expr_ext_t , elements : :: std :: os :: raw :: c_uint , mode : :: std :: os :: raw :: c_uint , platform : * const hs_platform_info_t , db : * mut * mut hs_database_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// The basic pure literal expression compiler.
///
/// This is the function call with which a pure literal expression (not a
/// common regular expression) is compiled into a Hyperscan database which
/// can be passed to the runtime functions (such as @ref hs_scan(),
/// @ref hs_open_stream(), etc.)
///
/// @param expression
/// The NULL-terminated expression to parse. Note that this string must
/// represent ONLY the pattern to be matched, with no delimiters or flags;
/// any global flags should be specified with the @p flags argument. For
/// example, the expression `/abc?def/i` should be compiled by providing
/// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
/// flags. Meanwhile, the string content shall be fully parsed in a literal
/// sense without any regular grammars. For example, the @p expression
/// `abc?` simply means a char sequence of `a`, `b`, `c`, and `?`. The `?`
/// here doesn't mean 0 or 1 quantifier under regular semantics.
///
/// @param flags
/// Flags which modify the behaviour of the expression. Multiple flags may
/// be used by ORing them together. Compared to @ref hs_compile(), fewer
/// valid values are provided:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated for the
/// expression per stream.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
///
/// @param len
/// The length of the text content of the pure literal expression. As the
/// text content indicated by @p expression is treated as single character
/// one by one, the special terminating character `\0` should be allowed
/// to appear in expression, and not treated as a terminator for a string.
/// Thus, the end of a pure literal expression cannot be indicated by
/// identifying `\0`, but by counting to the expression length.
///
/// @param mode
/// Compiler mode flags that affect the database as a whole. One of @ref
/// HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
/// supplied, to select between the generation of a streaming, block or
/// vectored database. In addition, other flags (beginning with HS_MODE_)
/// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
/// more details.
///
/// @param platform
/// If not NULL, the platform structure is used to determine the target
/// platform for the database. If NULL, a database suitable for running
/// on the current host platform is produced.
///
/// @param db
/// On success, a pointer to the generated database will be returned in
/// this parameter, or NULL on failure. The caller is responsible for
/// deallocating the buffer using the @ref hs_free_database() function.
///
/// @param error
/// If the compile fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the error
/// parameter. 
 pub fn hs_compile_lit ( expression : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_uint , len : usize , mode : :: std :: os :: raw :: c_uint , platform : * const hs_platform_info_t , db : * mut * mut hs_database_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// The multiple pure literal expression compiler.
///
/// This is the function call with which a set of pure literal expressions is
/// compiled into a database which can be passed to the runtime functions (such
/// as @ref hs_scan(), @ref hs_open_stream(), etc.) Each expression can be
/// labelled with a unique integer which is passed into the match callback to
/// identify the pattern that has matched.
///
/// @param expressions
/// The NULL-terminated expression to parse. Note that this string must
/// represent ONLY the pattern to be matched, with no delimiters or flags;
/// any global flags should be specified with the @p flags argument. For
/// example, the expression `/abc?def/i` should be compiled by providing
/// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
/// flags. Meanwhile, the string content shall be fully parsed in a literal
/// sense without any regular grammars. For example, the @p expression
/// `abc?` simply means a char sequence of `a`, `b`, `c`, and `?`. The `?`
/// here doesn't mean 0 or 1 quantifier under regular semantics.
///
/// @param flags
/// Array of flags which modify the behaviour of each expression. Multiple
/// flags may be used by ORing them together. Specifying the NULL pointer
/// in place of an array will set the flags value for all patterns to zero.
/// Compared to @ref hs_compile_multi(), fewer valid values are provided:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated for the
/// expression per stream.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
///
/// @param ids
/// An array of integers specifying the ID number to be associated with the
/// corresponding pattern in the expressions array. Specifying the NULL
/// pointer in place of an array will set the ID value for all patterns to
/// zero.
///
/// @param lens
/// Array of lengths of the text content of each pure literal expression.
/// As the text content indicated by @p expression is treated as single
/// character one by one, the special terminating character `\0` should be
/// allowed to appear in expression, and not treated as a terminator for a
/// string. Thus, the end of a pure literal expression cannot be indicated
/// by identifying `\0`, but by counting to the expression length.
///
/// @param elements
/// The number of elements in the input arrays.
///
/// @param mode
/// Compiler mode flags that affect the database as a whole. One of @ref
/// HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be
/// supplied, to select between the generation of a streaming, block or
/// vectored database. In addition, other flags (beginning with HS_MODE_)
/// may be supplied to enable specific features. See @ref HS_MODE_FLAG for
/// more details.
///
/// @param platform
/// If not NULL, the platform structure is used to determine the target
/// platform for the database. If NULL, a database suitable for running
/// on the current host platform is produced.
///
/// @param db
/// On success, a pointer to the generated database will be returned in
/// this parameter, or NULL on failure. The caller is responsible for
/// deallocating the buffer using the @ref hs_free_database() function.
///
/// @param error
/// If the compile fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the error
/// parameter. 
 pub fn hs_compile_lit_multi ( expressions : * const * const :: std :: os :: raw :: c_char , flags : * const :: std :: os :: raw :: c_uint , ids : * const :: std :: os :: raw :: c_uint , lens : * const usize , elements : :: std :: os :: raw :: c_uint , mode : :: std :: os :: raw :: c_uint , platform : * const hs_platform_info_t , db : * mut * mut hs_database_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// Free an error structure generated by @ref hs_compile(), @ref
/// hs_compile_multi() or @ref hs_compile_ext_multi().
///
/// @param error
/// The @ref hs_compile_error_t to be freed. NULL may also be safely
/// provided.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_free_compile_error ( error : * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// Utility function providing information about a regular expression. The
/// information provided in @ref hs_expr_info_t includes the minimum and maximum
/// width of a pattern match.
///
/// Note: successful analysis of an expression with this function does not imply
/// that compilation of the same expression (via @ref hs_compile(), @ref
/// hs_compile_multi() or @ref hs_compile_ext_multi()) would succeed. This
/// function may return @ref HS_SUCCESS for regular expressions that Hyperscan
/// cannot compile.
///
/// Note: some per-pattern flags (such as @ref HS_FLAG_ALLOWEMPTY, @ref
/// HS_FLAG_SOM_LEFTMOST) are accepted by this call, but as they do not affect
/// the properties returned in the @ref hs_expr_info_t structure, they will not
/// affect the outcome of this function.
///
/// @param expression
/// The NULL-terminated expression to parse. Note that this string must
/// represent ONLY the pattern to be matched, with no delimiters or flags;
/// any global flags should be specified with the @p flags argument.  For
/// example, the expression `/abc?def/i` should be compiled by providing
/// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
/// flags.
///
/// @param flags
/// Flags which modify the behaviour of the expression. Multiple flags may
/// be used by ORing them together. Valid values are:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated by the
/// expression per stream.
/// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
/// empty string, such as `.*`.
/// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
/// - HS_FLAG_UCP - Use Unicode properties for character classes.
/// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
/// - HS_FLAG_COMBINATION - Parse the expression in logical combination
/// syntax.
/// - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for
/// the sub-expressions in logical combinations.
///
/// @param info
/// On success, a pointer to the pattern information will be returned in
/// this parameter, or NULL on failure. This structure is allocated using
/// the allocator supplied in @ref hs_set_allocator() (or malloc() if no
/// allocator was set) and should be freed by the caller.
///
/// @param error
/// If the call fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the error
/// parameter. 
 pub fn hs_expression_info ( expression : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_uint , info : * mut * mut hs_expr_info_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// Utility function providing information about a regular expression, with
/// extended parameter support. The information provided in @ref hs_expr_info_t
/// includes the minimum and maximum width of a pattern match.
///
/// Note: successful analysis of an expression with this function does not imply
/// that compilation of the same expression (via @ref hs_compile(), @ref
/// hs_compile_multi() or @ref hs_compile_ext_multi()) would succeed. This
/// function may return @ref HS_SUCCESS for regular expressions that Hyperscan
/// cannot compile.
///
/// Note: some per-pattern flags (such as @ref HS_FLAG_ALLOWEMPTY, @ref
/// HS_FLAG_SOM_LEFTMOST) are accepted by this call, but as they do not affect
/// the properties returned in the @ref hs_expr_info_t structure, they will not
/// affect the outcome of this function.
///
/// @param expression
/// The NULL-terminated expression to parse. Note that this string must
/// represent ONLY the pattern to be matched, with no delimiters or flags;
/// any global flags should be specified with the @p flags argument.  For
/// example, the expression `/abc?def/i` should be compiled by providing
/// `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a
/// flags.
///
/// @param flags
/// Flags which modify the behaviour of the expression. Multiple flags may
/// be used by ORing them together. Valid values are:
/// - HS_FLAG_CASELESS - Matching will be performed case-insensitively.
/// - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.
/// - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.
/// - HS_FLAG_SINGLEMATCH - Only one match will be generated by the
/// expression per stream.
/// - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an
/// empty string, such as `.*`.
/// - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.
/// - HS_FLAG_UCP - Use Unicode properties for character classes.
/// - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.
/// - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset
/// when a match is found.
/// - HS_FLAG_COMBINATION - Parse the expression in logical combination
/// syntax.
/// - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for
/// the sub-expressions in logical combinations.
///
/// @param ext
/// A pointer to a filled @ref hs_expr_ext_t structure that defines
/// extended behaviour for this pattern. NULL may be specified if no
/// extended parameters are needed.
///
/// @param info
/// On success, a pointer to the pattern information will be returned in
/// this parameter, or NULL on failure. This structure is allocated using
/// the allocator supplied in @ref hs_set_allocator() (or malloc() if no
/// allocator was set) and should be freed by the caller.
///
/// @param error
/// If the call fails, a pointer to a @ref hs_compile_error_t will be
/// returned, providing details of the error condition. The caller is
/// responsible for deallocating the buffer using the @ref
/// hs_free_compile_error() function.
///
/// @return
/// @ref HS_SUCCESS is returned on successful compilation; @ref
/// HS_COMPILER_ERROR on failure, with details provided in the error
/// parameter. 
 pub fn hs_expression_ext_info ( expression : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_uint , ext : * const hs_expr_ext_t , info : * mut * mut hs_expr_info_t , error : * mut * mut hs_compile_error_t ) -> hs_error_t ; } extern "C" { 
 /// Populates the platform information based on the current host.
///
/// @param platform
/// On success, the pointed to structure is populated based on the current
/// host.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_populate_platform ( platform : * mut hs_platform_info_t ) -> hs_error_t ; } 
 /// Definition of the stream identifier type. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_stream { _unused : [ u8 ; 0 ] , } 
 /// The stream identifier returned by @ref hs_open_stream(). 
 pub type hs_stream_t = hs_stream ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hs_scratch { _unused : [ u8 ; 0 ] , } 
 /// A Hyperscan scratch space. 
 pub type hs_scratch_t = hs_scratch ; 
 /// Definition of the match event callback function type.
///
/// A callback function matching the defined type must be provided by the
/// application calling the @ref hs_scan(), @ref hs_scan_vector() or @ref
/// hs_scan_stream() functions (or other streaming calls which can produce
/// matches).
///
/// This callback function will be invoked whenever a match is located in the
/// target data during the execution of a scan. The details of the match are
/// passed in as parameters to the callback function, and the callback function
/// should return a value indicating whether or not matching should continue on
/// the target data. If no callbacks are desired from a scan call, NULL may be
/// provided in order to suppress match production.
///
/// This callback function should not attempt to call Hyperscan API functions on
/// the same stream nor should it attempt to reuse the scratch space allocated
/// for the API calls that caused it to be triggered. Making another call to the
/// Hyperscan library with completely independent parameters should work (for
/// example, scanning a different database in a new stream and with new scratch
/// space), but reusing data structures like stream state and/or scratch space
/// will produce undefined behavior.
///
/// @param id
/// The ID number of the expression that matched. If the expression was a
/// single expression compiled with @ref hs_compile(), this value will be
/// zero.
///
/// @param from
/// - If a start of match flag is enabled for the current pattern, this
/// argument will be set to the start of match for the pattern assuming
/// that that start of match value lies within the current 'start of match
/// horizon' chosen by one of the SOM_HORIZON mode flags.
///
/// - If the start of match value lies outside this horizon (possible only
/// when the SOM_HORIZON value is not @ref HS_MODE_SOM_HORIZON_LARGE),
/// the @p from value will be set to @ref HS_OFFSET_PAST_HORIZON.
///
/// - This argument will be set to zero if the Start of Match flag is not
/// enabled for the given pattern.
///
/// @param to
/// The offset after the last byte that matches the expression.
///
/// @param flags
/// This is provided for future use and is unused at present.
///
/// @param context
/// The pointer supplied by the user to the @ref hs_scan(), @ref
/// hs_scan_vector() or @ref hs_scan_stream() function.
///
/// @return
/// Non-zero if the matching should cease, else zero. If scanning is
/// performed in streaming mode and a non-zero value is returned, any
/// subsequent calls to @ref hs_scan_stream() for that stream will
/// immediately return with @ref HS_SCAN_TERMINATED. 
 pub type match_event_handler = :: std :: option :: Option < unsafe extern "C" fn ( id : :: std :: os :: raw :: c_uint , from : :: std :: os :: raw :: c_ulonglong , to : :: std :: os :: raw :: c_ulonglong , flags : :: std :: os :: raw :: c_uint , context : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { 
 /// Open and initialise a stream.
///
/// @param db
/// A compiled pattern database.
///
/// @param flags
/// Flags modifying the behaviour of the stream. This parameter is provided
/// for future use and is unused at present.
///
/// @param stream
/// On success, a pointer to the generated @ref hs_stream_t will be
/// returned; NULL on failure.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_open_stream ( db : * const hs_database_t , flags : :: std :: os :: raw :: c_uint , stream : * mut * mut hs_stream_t ) -> hs_error_t ; } extern "C" { 
 /// Write data to be scanned to the opened stream.
///
/// This is the function call in which the actual pattern matching takes place
/// as data is written to the stream. Matches will be returned via the @ref
/// match_event_handler callback supplied.
///
/// @param id
/// The stream ID (returned by @ref hs_open_stream()) to which the data
/// will be written.
///
/// @param data
/// Pointer to the data to be scanned.
///
/// @param length
/// The number of bytes to scan.
///
/// @param flags
/// Flags modifying the behaviour of the stream. This parameter is provided
/// for future use and is unused at present.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch().
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param ctxt
/// The user defined pointer which will be passed to the callback function
/// when a match occurs.
///
/// @return
/// Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the
/// match callback indicated that scanning should stop; other values on
/// error. 
 pub fn hs_scan_stream ( id : * mut hs_stream_t , data : * const :: std :: os :: raw :: c_char , length : :: std :: os :: raw :: c_uint , flags : :: std :: os :: raw :: c_uint , scratch : * mut hs_scratch_t , onEvent : match_event_handler , ctxt : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// Close a stream.
///
/// This function completes matching on the given stream and frees the memory
/// associated with the stream state. After this call, the stream pointed to by
/// @p id is invalid and can no longer be used. To reuse the stream state after
/// completion, rather than closing it, the @ref hs_reset_stream function can be
/// used.
///
/// This function must be called for any stream created with @ref
/// hs_open_stream(), even if scanning has been terminated by a non-zero return
/// from the match callback function.
///
/// Note: This operation may result in matches being returned (via calls to the
/// match event callback) for expressions anchored to the end of the data stream
/// (for example, via the use of the `$` meta-character). If these matches are
/// not desired, NULL may be provided as the @ref match_event_handler callback.
///
/// If NULL is provided as the @ref match_event_handler callback, it is
/// permissible to provide a NULL scratch.
///
/// @param id
/// The stream ID returned by @ref hs_open_stream().
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
/// allowed to be NULL only if the @p onEvent callback is also NULL.
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param ctxt
/// The user defined pointer which will be passed to the callback function
/// when a match occurs.
///
/// @return
/// Returns @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_close_stream ( id : * mut hs_stream_t , scratch : * mut hs_scratch_t , onEvent : match_event_handler , ctxt : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// Reset a stream to an initial state.
///
/// Conceptually, this is equivalent to performing @ref hs_close_stream() on the
/// given stream, followed by a @ref hs_open_stream(). This new stream replaces
/// the original stream in memory, avoiding the overhead of freeing the old
/// stream and allocating the new one.
///
/// Note: This operation may result in matches being returned (via calls to the
/// match event callback) for expressions anchored to the end of the original
/// data stream (for example, via the use of the `$` meta-character). If these
/// matches are not desired, NULL may be provided as the @ref match_event_handler
/// callback.
///
/// Note: the stream will also be tied to the same database.
///
/// @param id
/// The stream (as created by @ref hs_open_stream()) to be replaced.
///
/// @param flags
/// Flags modifying the behaviour of the stream. This parameter is provided
/// for future use and is unused at present.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
/// allowed to be NULL only if the @p onEvent callback is also NULL.
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param context
/// The user defined pointer which will be passed to the callback function
/// when a match occurs.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_reset_stream ( id : * mut hs_stream_t , flags : :: std :: os :: raw :: c_uint , scratch : * mut hs_scratch_t , onEvent : match_event_handler , context : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// Duplicate the given stream. The new stream will have the same state as the
/// original including the current stream offset.
///
/// @param to_id
/// On success, a pointer to the new, copied @ref hs_stream_t will be
/// returned; NULL on failure.
///
/// @param from_id
/// The stream (as created by @ref hs_open_stream()) to be copied.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_copy_stream ( to_id : * mut * mut hs_stream_t , from_id : * const hs_stream_t ) -> hs_error_t ; } extern "C" { 
 /// Duplicate the given 'from' stream state onto the 'to' stream. The 'to' stream
/// will first be reset (reporting any EOD matches if a non-NULL @p onEvent
/// callback handler is provided).
///
/// Note: the 'to' stream and the 'from' stream must be open against the same
/// database.
///
/// @param to_id
/// On success, a pointer to the new, copied @ref hs_stream_t will be
/// returned; NULL on failure.
///
/// @param from_id
/// The stream (as created by @ref hs_open_stream()) to be copied.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
/// allowed to be NULL only if the @p onEvent callback is also NULL.
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param context
/// The user defined pointer which will be passed to the callback function
/// when a match occurs.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_reset_and_copy_stream ( to_id : * mut hs_stream_t , from_id : * const hs_stream_t , scratch : * mut hs_scratch_t , onEvent : match_event_handler , context : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// Creates a compressed representation of the provided stream in the buffer
/// provided. This compressed representation can be converted back into a stream
/// state by using @ref hs_expand_stream() or @ref hs_reset_and_expand_stream().
/// The size of the compressed representation will be placed into @p used_space.
///
/// If there is not sufficient space in the buffer to hold the compressed
/// representation, @ref HS_INSUFFICIENT_SPACE will be returned and @p used_space
/// will be populated with the amount of space required.
///
/// Note: this function does not close the provided stream, you may continue to
/// use the stream or to free it with @ref hs_close_stream().
///
/// @param stream
/// The stream (as created by @ref hs_open_stream()) to be compressed.
///
/// @param buf
/// Buffer to write the compressed representation into. Note: if the call is
/// just being used to determine the amount of space required, it is allowed
/// to pass NULL here and @p buf_space as 0.
///
/// @param buf_space
/// The number of bytes in @p buf. If buf_space is too small, the call will
/// fail with @ref HS_INSUFFICIENT_SPACE.
///
/// @param used_space
/// Pointer to where the amount of used space will be written to. The used
/// buffer space is always less than or equal to @p buf_space. If the call
/// fails with @ref HS_INSUFFICIENT_SPACE, this pointer will be used to
/// write out the amount of buffer space required.
///
/// @return
/// @ref HS_SUCCESS on success, @ref HS_INSUFFICIENT_SPACE if the provided
/// buffer is too small. 
 pub fn hs_compress_stream ( stream : * const hs_stream_t , buf : * mut :: std :: os :: raw :: c_char , buf_space : usize , used_space : * mut usize ) -> hs_error_t ; } extern "C" { 
 /// Decompresses a compressed representation created by @ref hs_compress_stream()
/// into a new stream.
///
/// Note: @p buf must correspond to a complete compressed representation created
/// by @ref hs_compress_stream() of a stream that was opened against @p db. It is
/// not always possible to detect misuse of this API and behaviour is undefined
/// if these properties are not satisfied.
///
/// @param db
/// The compiled pattern database that the compressed stream was opened
/// against.
///
/// @param stream
/// On success, a pointer to the expanded @ref hs_stream_t will be
/// returned; NULL on failure.
///
/// @param buf
/// A compressed representation of a stream. These compressed forms are
/// created by @ref hs_compress_stream().
///
/// @param buf_size
/// The size in bytes of the compressed representation.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_expand_stream ( db : * const hs_database_t , stream : * mut * mut hs_stream_t , buf : * const :: std :: os :: raw :: c_char , buf_size : usize ) -> hs_error_t ; } extern "C" { 
 /// Decompresses a compressed representation created by @ref hs_compress_stream()
/// on top of the 'to' stream. The 'to' stream will first be reset (reporting
/// any EOD matches if a non-NULL @p onEvent callback handler is provided).
///
/// Note: the 'to' stream must be opened against the same database as the
/// compressed stream.
///
/// Note: @p buf must correspond to a complete compressed representation created
/// by @ref hs_compress_stream() of a stream that was opened against @p db. It is
/// not always possible to detect misuse of this API and behaviour is undefined
/// if these properties are not satisfied.
///
/// @param to_stream
/// A pointer to a valid stream state. A pointer to the expanded @ref
/// hs_stream_t will be returned; NULL on failure.
///
/// @param buf
/// A compressed representation of a stream. These compressed forms are
/// created by @ref hs_compress_stream().
///
/// @param buf_size
/// The size in bytes of the compressed representation.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is
/// allowed to be NULL only if the @p onEvent callback is also NULL.
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param context
/// The user defined pointer which will be passed to the callback function
/// when a match occurs.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_reset_and_expand_stream ( to_stream : * mut hs_stream_t , buf : * const :: std :: os :: raw :: c_char , buf_size : usize , scratch : * mut hs_scratch_t , onEvent : match_event_handler , context : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// The block (non-streaming) regular expression scanner.
///
/// This is the function call in which the actual pattern matching takes place
/// for block-mode pattern databases.
///
/// @param db
/// A compiled pattern database.
///
/// @param data
/// Pointer to the data to be scanned.
///
/// @param length
/// The number of bytes to scan.
///
/// @param flags
/// Flags modifying the behaviour of this function. This parameter is
/// provided for future use and is unused at present.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch() for this
/// database.
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param context
/// The user defined pointer which will be passed to the callback function.
///
/// @return
/// Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the
/// match callback indicated that scanning should stop; other values on
/// error. 
 pub fn hs_scan ( db : * const hs_database_t , data : * const :: std :: os :: raw :: c_char , length : :: std :: os :: raw :: c_uint , flags : :: std :: os :: raw :: c_uint , scratch : * mut hs_scratch_t , onEvent : match_event_handler , context : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// The vectored regular expression scanner.
///
/// This is the function call in which the actual pattern matching takes place
/// for vectoring-mode pattern databases.
///
/// @param db
/// A compiled pattern database.
///
/// @param data
/// An array of pointers to the data blocks to be scanned.
///
/// @param length
/// An array of lengths (in bytes) of each data block to scan.
///
/// @param count
/// Number of data blocks to scan. This should correspond to the size of
/// of the @p data and @p length arrays.
///
/// @param flags
/// Flags modifying the behaviour of this function. This parameter is
/// provided for future use and is unused at present.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch() for
/// this database.
///
/// @param onEvent
/// Pointer to a match event callback function. If a NULL pointer is given,
/// no matches will be returned.
///
/// @param context
/// The user defined pointer which will be passed to the callback function.
///
/// @return
/// Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the match
/// callback indicated that scanning should stop; other values on error. 
 pub fn hs_scan_vector ( db : * const hs_database_t , data : * const * const :: std :: os :: raw :: c_char , length : * const :: std :: os :: raw :: c_uint , count : :: std :: os :: raw :: c_uint , flags : :: std :: os :: raw :: c_uint , scratch : * mut hs_scratch_t , onEvent : match_event_handler , context : * mut :: std :: os :: raw :: c_void ) -> hs_error_t ; } extern "C" { 
 /// Allocate a "scratch" space for use by Hyperscan.
///
/// This is required for runtime use, and one scratch space per thread, or
/// concurrent caller, is required. Any allocator callback set by @ref
/// hs_set_scratch_allocator() or @ref hs_set_allocator() will be used by this
/// function.
///
/// @param db
/// The database, as produced by @ref hs_compile().
///
/// @param scratch
/// On first allocation, a pointer to NULL should be provided so a new
/// scratch can be allocated. If a scratch block has been previously
/// allocated, then a pointer to it should be passed back in to see if it
/// is valid for this database block. If a new scratch block is required,
/// the original will be freed and the new one returned, otherwise the
/// previous scratch block will be returned. On success, the scratch block
/// will be suitable for use with the provided database in addition to any
/// databases that original scratch space was suitable for.
///
/// @return
/// @ref HS_SUCCESS on successful allocation; @ref HS_NOMEM if the
/// allocation fails.  Other errors may be returned if invalid parameters
/// are specified. 
 pub fn hs_alloc_scratch ( db : * const hs_database_t , scratch : * mut * mut hs_scratch_t ) -> hs_error_t ; } extern "C" { 
 /// Allocate a scratch space that is a clone of an existing scratch space.
///
/// This is useful when multiple concurrent threads will be using the same set
/// of compiled databases, and another scratch space is required. Any allocator
/// callback set by @ref hs_set_scratch_allocator() or @ref hs_set_allocator()
/// will be used by this function.
///
/// @param src
/// The existing @ref hs_scratch_t to be cloned.
///
/// @param dest
/// A pointer to the new scratch space will be returned here.
///
/// @return
/// @ref HS_SUCCESS on success; @ref HS_NOMEM if the allocation fails.
/// Other errors may be returned if invalid parameters are specified. 
 pub fn hs_clone_scratch ( src : * const hs_scratch_t , dest : * mut * mut hs_scratch_t ) -> hs_error_t ; } extern "C" { 
 /// Provides the size of the given scratch space.
///
/// @param scratch
/// A per-thread scratch space allocated by @ref hs_alloc_scratch() or @ref
/// hs_clone_scratch().
///
/// @param scratch_size
/// On success, the size of the scratch space in bytes is placed in this
/// parameter.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_scratch_size ( scratch : * const hs_scratch_t , scratch_size : * mut usize ) -> hs_error_t ; } extern "C" { 
 /// Free a scratch block previously allocated by @ref hs_alloc_scratch() or @ref
/// hs_clone_scratch().
///
/// The free callback set by @ref hs_set_scratch_allocator() or @ref
/// hs_set_allocator() will be used by this function.
///
/// @param scratch
/// The scratch block to be freed. NULL may also be safely provided.
///
/// @return
/// @ref HS_SUCCESS on success, other values on failure. 
 pub fn hs_free_scratch ( scratch : * mut hs_scratch_t ) -> hs_error_t ; }